// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"

	"nimona.io/internal/tilde"
)

var _ = zero.IsZeroVal
var _ = tilde.NewScanner

func (t *NetworkAnnouncePeerRequest) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkAnnouncePeerRequest) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/announcePeer.request"))
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	// # t.PeerInfo
	//
	// Type: nimona.PeerInfo, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.PeerInfo) {
			m.Set("peerInfo", t.PeerInfo.Map())
		}
	}

	return m
}

func (t *NetworkAnnouncePeerRequest) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkAnnouncePeerRequest) FromMap(d tilde.Map) error {
	*t = NetworkAnnouncePeerRequest{}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Metadata = e
			}
		}
	}

	// # t.PeerInfo
	//
	// Type: nimona.PeerInfo, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("peerInfo"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := PeerInfo{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.PeerInfo = e
			}
		}
	}

	return nil
}
func (t *NetworkAnnouncePeerResponse) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkAnnouncePeerResponse) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/announcePeer.response"))
	}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Error) {
			m.Set("error", tilde.Bool(t.Error))
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.ErrorDescription) {
			m.Set("errorDescription", tilde.String(t.ErrorDescription))
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	return m
}

func (t *NetworkAnnouncePeerResponse) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkAnnouncePeerResponse) FromMap(d tilde.Map) error {
	*t = NetworkAnnouncePeerResponse{}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("error"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Error = bool(v)
			}
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("errorDescription"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.ErrorDescription = string(v)
			}
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Metadata = e
			}
		}
	}

	return nil
}
func (t *NetworkInfoRequest) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkInfoRequest) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/info.request"))
	}

	return m
}

func (t *NetworkInfoRequest) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkInfoRequest) FromMap(d tilde.Map) error {
	*t = NetworkInfoRequest{}

	return nil
}
func (t *NetworkJoinRequest) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkJoinRequest) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/join.request"))
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	// # t.RequestedHandle
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.RequestedHandle) {
			m.Set("requestedHandle", tilde.String(t.RequestedHandle))
		}
	}

	return m
}

func (t *NetworkJoinRequest) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkJoinRequest) FromMap(d tilde.Map) error {
	*t = NetworkJoinRequest{}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Metadata = e
			}
		}
	}

	// # t.RequestedHandle
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("requestedHandle"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.RequestedHandle = string(v)
			}
		}
	}

	return nil
}
func (t *NetworkJoinResponse) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkJoinResponse) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/join.response"))
	}

	// # t.Accepted
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("accepted", tilde.Bool(t.Accepted))
	}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Error) {
			m.Set("error", tilde.Bool(t.Error))
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.ErrorDescription) {
			m.Set("errorDescription", tilde.String(t.ErrorDescription))
		}
	}

	// # t.Handle
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Handle) {
			m.Set("handle", tilde.String(t.Handle))
		}
	}

	return m
}

func (t *NetworkJoinResponse) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkJoinResponse) FromMap(d tilde.Map) error {
	*t = NetworkJoinResponse{}

	// # t.Accepted
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("accepted"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Accepted = bool(v)
			}
		}
	}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("error"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Error = bool(v)
			}
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("errorDescription"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.ErrorDescription = string(v)
			}
		}
	}

	// # t.Handle
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("handle"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.Handle = string(v)
			}
		}
	}

	return nil
}
func (t *NetworkLookupPeerRequest) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkLookupPeerRequest) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/lookupPeer.request"))
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	// # t.PeerKey
	//
	// Type: nimona.PeerKey, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.PeerKey) {
			m.Set("peerKey", t.PeerKey.Map())
		}
	}

	return m
}

func (t *NetworkLookupPeerRequest) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkLookupPeerRequest) FromMap(d tilde.Map) error {
	*t = NetworkLookupPeerRequest{}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Metadata = e
			}
		}
	}

	// # t.PeerKey
	//
	// Type: nimona.PeerKey, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("peerKey"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := PeerKey{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.PeerKey = e
			}
		}
	}

	return nil
}
func (t *NetworkLookupPeerResponse) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkLookupPeerResponse) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/lookupPeer.response"))
	}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Error) {
			m.Set("error", tilde.Bool(t.Error))
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.ErrorDescription) {
			m.Set("errorDescription", tilde.String(t.ErrorDescription))
		}
	}

	// # t.Found
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Found) {
			m.Set("found", tilde.Bool(t.Found))
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	// # t.PeerInfo
	//
	// Type: nimona.PeerInfo, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.PeerInfo) {
			m.Set("peerInfo", t.PeerInfo.Map())
		}
	}

	return m
}

func (t *NetworkLookupPeerResponse) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkLookupPeerResponse) FromMap(d tilde.Map) error {
	*t = NetworkLookupPeerResponse{}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("error"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Error = bool(v)
			}
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("errorDescription"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.ErrorDescription = string(v)
			}
		}
	}

	// # t.Found
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("found"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Found = bool(v)
			}
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Metadata = e
			}
		}
	}

	// # t.PeerInfo
	//
	// Type: nimona.PeerInfo, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("peerInfo"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := PeerInfo{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.PeerInfo = e
			}
		}
	}

	return nil
}
func (t *NetworkResolveHandleRequest) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkResolveHandleRequest) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/resolveHandle.request"))
	}

	// # t.Handle
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Handle) {
			m.Set("handle", tilde.String(t.Handle))
		}
	}

	return m
}

func (t *NetworkResolveHandleRequest) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkResolveHandleRequest) FromMap(d tilde.Map) error {
	*t = NetworkResolveHandleRequest{}

	// # t.Handle
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("handle"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.Handle = string(v)
			}
		}
	}

	return nil
}
func (t *NetworkResolveHandleResponse) Document() *Document {
	return NewDocument(t.Map())
}

func (t *NetworkResolveHandleResponse) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/network/resolveHandle.response"))
	}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Error) {
			m.Set("error", tilde.Bool(t.Error))
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.ErrorDescription) {
			m.Set("errorDescription", tilde.String(t.ErrorDescription))
		}
	}

	// # t.Found
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Found) {
			m.Set("found", tilde.Bool(t.Found))
		}
	}

	// # t.IdentityID
	//
	// Type: nimona.Identity, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.IdentityID) {
			m.Set("identityID", t.IdentityID.Map())
		}
	}

	// # t.PeerAddresses
	//
	// Type: []nimona.PeerAddr, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.PeerAddr, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.PeerAddresses) {
			sm := tilde.List{}
			for _, v := range t.PeerAddresses {
				if !zero.IsZeroVal(t.PeerAddresses) {
					sm = append(sm, v.Map())
				}
			}
			m.Set("peerAddresses", sm)
		}
	}

	return m
}

func (t *NetworkResolveHandleResponse) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *NetworkResolveHandleResponse) FromMap(d tilde.Map) error {
	*t = NetworkResolveHandleResponse{}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("error"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Error = bool(v)
			}
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("errorDescription"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.ErrorDescription = string(v)
			}
		}
	}

	// # t.Found
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("found"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Found = bool(v)
			}
		}
	}

	// # t.IdentityID
	//
	// Type: nimona.Identity, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("identityID"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Identity{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.IdentityID = e
			}
		}
	}

	// # t.PeerAddresses
	//
	// Type: []nimona.PeerAddr, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.PeerAddr, ElemKind: struct, ElemTildeKind: Map
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []PeerAddr{}
		if vs, err := d.Get("peerAddresses"); err == nil {
			if vs, ok := vs.(tilde.List); ok {
				for _, vi := range vs {
					if v, ok := vi.(tilde.Map); ok {
						e := PeerAddr{}
						d := NewDocument(v)
						e.FromDocument(d)
						sm = append(sm, e)
					}
				}
			}
		}
		if len(sm) > 0 {
			t.PeerAddresses = sm
		}
	}

	return nil
}
