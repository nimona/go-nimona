package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/importer"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

var (
	schema   = flag.String("schema", "", "schema for struct")
	input    = flag.String("in", "", "input file")
	output   = flag.String("out", "-", "output file (default is stdout)")
	typename = flag.String("type", "", "type to generate methods for")
)

func init() {
	flag.Parse()
}

func main() {
	gen := Generator{
		InputFile: *input,
		Type:      *typename,
	}

	code, err := gen.process()
	if err != nil {
		log.Fatal(err)
	}

	if *output == "-" {
		os.Stdout.Write(code)
	} else if err := ioutil.WriteFile(*output, code, 0644); err != nil {
		log.Fatal(err)
	}
}

type Generator struct {
	InputFile string
	Type      string
	Importer  types.Importer
	FileSet   *token.FileSet
}

type Values struct {
	Package    string
	StructName string
	Schema     string
	Imports    map[string]bool
}

func (gen *Generator) process() (code []byte, err error) {
	if gen.FileSet == nil {
		gen.FileSet = token.NewFileSet()
	}
	if gen.Importer == nil {
		gen.Importer = importer.Default()
	}
	pkg, err := gen.loadPackage()
	if err != nil {
		return nil, err
	}

	values := &Values{
		Package:    pkg.Name,
		StructName: gen.Type,
		Schema:     *schema,
		Imports: map[string]bool{
			"github.com/mitchellh/mapstructure": true,
		},
	}

	if pkg.PkgPath != "object" {
		values.Imports["nimona.io/pkg/object"] = true
	}

	fmt.Printf("Objectifying %s.%s\n", values.Package, gen.Type)

	// nolint
	tpl := `// Code generated by nimona.io/tools/objectify. DO NOT EDIT.

// +build !generate

package {{ .Package }}

import (
	"fmt"

	{{- range $pkg, $ok := .Imports }}
	"{{ $pkg }}"
	{{- end }}
)

const (
	{{ .StructName }}Type = "{{ .Schema }}"
)

// ToObject returns a f12n object
func (s {{ .StructName }}) ToObject() object.Object {
	m := map[string]interface{}{
		"@ctx:s": {{ .StructName }}Type,
	}
	b, _ := json.Marshal(s)
	json.Unmarshal(b, &m)
	return object.Object(m)
}

// FromObject populates the struct from a f12n object
func (s *{{ .StructName }}) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, s)
}

// GetType returns the object's type
func (s {{ .StructName }}) GetType() string {
	return {{ .StructName }}Type
}`

	f, err := os.Create(*output)
	if err != nil {
		panic(err)
	}

	t, err := template.New("t").Parse(tpl)
	if err != nil {
		panic(err)
	}

	out := bytes.NewBuffer([]byte{})
	if err := t.Execute(out, values); err != nil {
		panic(err)
	}

	if values.Package == "object" {
		sout := strings.Replace(string(out.Bytes()), "object.", "", -1)
		out = bytes.NewBuffer([]byte(sout))
	}

	if _, err := f.Write(out.Bytes()); err != nil {
		panic(err)
	}

	opt := &imports.Options{
		Comments:  true,
		TabIndent: true,
		TabWidth:  8,
	}
	code, err = imports.Process(*output, code, opt)
	if err != nil {
		panic(fmt.Errorf("BUG: can't gofmt generated code: %v", err))
	}
	return code, nil
}

func (gen *Generator) loadPackage() (*packages.Package, error) {
	pattern := "file=" + gen.InputFile
	lcfg := &packages.Config{
		Mode: packages.LoadAllSyntax,
		Fset: gen.FileSet,
		Env:  os.Environ(),
	}
	pkgs, err := packages.Load(lcfg, pattern)
	if err != nil {
		return nil, err
	}
	if len(pkgs) == 0 {
		return nil, errors.New("no files found")
	}
	return pkgs[0], nil
}
