// Code generated by nimona.io/tools/objectify. DO NOT EDIT.

// +build !generate

package example

import (
	"nimona.io/pkg/object"
)

const (
	InnerFooType = "test/inn"
)

// ToObject returns a f12n object
func (s InnerFoo) ToObject() *object.Object {
	o := object.New()
	o.SetType(InnerFooType)
	if s.InnerBar != "" {
		o.SetRaw("inner_bar", s.InnerBar)
	}
	if len(s.InnerBars) > 0 {
		o.SetRaw("inner_bars", s.InnerBars)
	}
	if len(s.MoreInnerFoos) > 0 {
		o.SetRaw("inner_foos", s.MoreInnerFoos)
	}
	o.SetRaw("i", s.I)
	o.SetRaw("i8", s.I8)
	o.SetRaw("i16", s.I16)
	o.SetRaw("i32", s.I32)
	o.SetRaw("i64", s.I64)
	o.SetRaw("u", s.U)
	o.SetRaw("u8", s.U8)
	o.SetRaw("u16", s.U16)
	o.SetRaw("u32", s.U32)
	o.SetRaw("f32", s.F32)
	o.SetRaw("f64", s.F64)
	if len(s.Ai8) > 0 {
		o.SetRaw("ai8", s.Ai8)
	}
	if len(s.Ai16) > 0 {
		o.SetRaw("ai16", s.Ai16)
	}
	if len(s.Ai32) > 0 {
		o.SetRaw("ai32", s.Ai32)
	}
	if len(s.Ai64) > 0 {
		o.SetRaw("ai64", s.Ai64)
	}
	if len(s.Au16) > 0 {
		o.SetRaw("au16", s.Au16)
	}
	if len(s.Au32) > 0 {
		o.SetRaw("au32", s.Au32)
	}
	if len(s.Af32) > 0 {
		o.SetRaw("af32", s.Af32)
	}
	if len(s.Af64) > 0 {
		o.SetRaw("af64", s.Af64)
	}
	return o
}

// FromObject populates the struct from a f12n object
func (s *InnerFoo) FromObject(o *object.Object) error {
	if v, ok := o.GetRaw("inner_bar").(string); ok {
		s.InnerBar = v
	}
	if ss, ok := o.GetRaw("inner_bars").([]string); ok {
		s.InnerBars = ss
	} else if ss, ok := o.GetRaw("inner_bars").([]interface{}); ok {
		s.InnerBars = []string{}
		for _, si := range ss {
			if v, ok := si.(string); ok {
				s.InnerBars = append(s.InnerBars, v)
			}
		}
	}
	if ss, ok := o.GetRaw("inner_foos").([]*InnerFoo); ok {
		s.MoreInnerFoos = ss
	} else if ss, ok := o.GetRaw("inner_foos").([]interface{}); ok {
		s.MoreInnerFoos = []*InnerFoo{}
		for _, si := range ss {
			if v, ok := si.(*InnerFoo); ok {
				s.MoreInnerFoos = append(s.MoreInnerFoos, v)
			} else if v, ok := si.(*object.Object); ok {
				sMoreInnerFoos := &InnerFoo{}
				if err := sMoreInnerFoos.FromObject(v); err != nil {
					return err
				}
				s.MoreInnerFoos = append(s.MoreInnerFoos, sMoreInnerFoos)
			}
		}
	}
	if v, ok := o.GetRaw("i").(int); ok {
		s.I = v
	}
	if v, ok := o.GetRaw("i8").(int8); ok {
		s.I8 = v
	}
	if v, ok := o.GetRaw("i16").(int16); ok {
		s.I16 = v
	}
	if v, ok := o.GetRaw("i32").(int32); ok {
		s.I32 = v
	}
	if v, ok := o.GetRaw("i64").(int64); ok {
		s.I64 = v
	}
	if v, ok := o.GetRaw("u").(uint); ok {
		s.U = v
	}
	if v, ok := o.GetRaw("u8").(uint8); ok {
		s.U8 = v
	}
	if v, ok := o.GetRaw("u16").(uint16); ok {
		s.U16 = v
	}
	if v, ok := o.GetRaw("u32").(uint32); ok {
		s.U32 = v
	}
	if v, ok := o.GetRaw("f32").(float32); ok {
		s.F32 = v
	}
	if v, ok := o.GetRaw("f64").(float64); ok {
		s.F64 = v
	}
	if ss, ok := o.GetRaw("ai8").([]int8); ok {
		s.Ai8 = ss
	} else if ss, ok := o.GetRaw("ai8").([]interface{}); ok {
		s.Ai8 = []int8{}
		for _, si := range ss {
			if v, ok := si.(int8); ok {
				s.Ai8 = append(s.Ai8, v)
			}
		}
	}
	if ss, ok := o.GetRaw("ai16").([]int16); ok {
		s.Ai16 = ss
	} else if ss, ok := o.GetRaw("ai16").([]interface{}); ok {
		s.Ai16 = []int16{}
		for _, si := range ss {
			if v, ok := si.(int16); ok {
				s.Ai16 = append(s.Ai16, v)
			}
		}
	}
	if ss, ok := o.GetRaw("ai32").([]int32); ok {
		s.Ai32 = ss
	} else if ss, ok := o.GetRaw("ai32").([]interface{}); ok {
		s.Ai32 = []int32{}
		for _, si := range ss {
			if v, ok := si.(int32); ok {
				s.Ai32 = append(s.Ai32, v)
			}
		}
	}
	if ss, ok := o.GetRaw("ai64").([]int64); ok {
		s.Ai64 = ss
	} else if ss, ok := o.GetRaw("ai64").([]interface{}); ok {
		s.Ai64 = []int64{}
		for _, si := range ss {
			if v, ok := si.(int64); ok {
				s.Ai64 = append(s.Ai64, v)
			}
		}
	}
	if ss, ok := o.GetRaw("au16").([]uint16); ok {
		s.Au16 = ss
	} else if ss, ok := o.GetRaw("au16").([]interface{}); ok {
		s.Au16 = []uint16{}
		for _, si := range ss {
			if v, ok := si.(uint16); ok {
				s.Au16 = append(s.Au16, v)
			}
		}
	}
	if ss, ok := o.GetRaw("au32").([]uint32); ok {
		s.Au32 = ss
	} else if ss, ok := o.GetRaw("au32").([]interface{}); ok {
		s.Au32 = []uint32{}
		for _, si := range ss {
			if v, ok := si.(uint32); ok {
				s.Au32 = append(s.Au32, v)
			}
		}
	}
	if ss, ok := o.GetRaw("af32").([]float32); ok {
		s.Af32 = ss
	} else if ss, ok := o.GetRaw("af32").([]interface{}); ok {
		s.Af32 = []float32{}
		for _, si := range ss {
			if v, ok := si.(float32); ok {
				s.Af32 = append(s.Af32, v)
			}
		}
	}
	if ss, ok := o.GetRaw("af64").([]float64); ok {
		s.Af64 = ss
	} else if ss, ok := o.GetRaw("af64").([]interface{}); ok {
		s.Af64 = []float64{}
		for _, si := range ss {
			if v, ok := si.(float64); ok {
				s.Af64 = append(s.Af64, v)
			}
		}
	}
	return nil
}

// GetType returns the object's type
func (s InnerFoo) GetType() string {
	return InnerFooType
}
