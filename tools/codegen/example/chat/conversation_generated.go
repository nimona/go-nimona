// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package chat

import (
	"nimona.io/pkg/immutable"
	object "nimona.io/pkg/object"
)

type (
	ConversationCreated struct {
		Header object.Header
		Name   string
	}
	ConversationTopicUpdated struct {
		Header    object.Header
		Topic     string
		DependsOn []object.Hash
	}
	ConversationMessageAdded struct {
		Header    object.Header
		Body      string
		DependsOn []object.Hash
	}
	ConversationMessageRemoved struct {
		Header    object.Header
		Removes   object.Hash
		DependsOn []object.Hash
	}
)

func (e ConversationCreated) GetType() string {
	return "mochi.io/conversation.Created"
}

func (e ConversationCreated) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "name",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e ConversationCreated) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Name != "" {
		d["name:s"] = e.Name
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("mochi.io/conversation.Created")
	return o
}

func (e *ConversationCreated) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("name:s"); v != nil {
		e.Name = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e ConversationTopicUpdated) GetType() string {
	return "mochi.io/conversation.TopicUpdated"
}

func (e ConversationTopicUpdated) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "topic",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "dependsOn",
				Type:       "relationship",
				Hint:       "r",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e ConversationTopicUpdated) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Topic != "" {
		d["topic:s"] = e.Topic
	}
	if len(e.DependsOn) > 0 {
		d["dependsOn:ar"] = e.DependsOn
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("mochi.io/conversation.TopicUpdated")
	return o
}

func (e *ConversationTopicUpdated) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("topic:s"); v != nil {
		e.Topic = string(v.PrimitiveHinted().(string))
	}
	if v := o.Data.Value("dependsOn:ar"); v != nil && v.IsList() {
		// TODO missing implementation for repeated type hint r
	}
	return nil
}

func (e ConversationMessageAdded) GetType() string {
	return "mochi.io/conversation.MessageAdded"
}

func (e ConversationMessageAdded) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "body",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "dependsOn",
				Type:       "relationship",
				Hint:       "r",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e ConversationMessageAdded) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Body != "" {
		d["body:s"] = e.Body
	}
	if len(e.DependsOn) > 0 {
		d["dependsOn:ar"] = e.DependsOn
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("mochi.io/conversation.MessageAdded")
	return o
}

func (e *ConversationMessageAdded) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("body:s"); v != nil {
		e.Body = string(v.PrimitiveHinted().(string))
	}
	if v := o.Data.Value("dependsOn:ar"); v != nil && v.IsList() {
		// TODO missing implementation for repeated type hint r
	}
	return nil
}

func (e ConversationMessageRemoved) GetType() string {
	return "mochi.io/conversation.MessageRemoved"
}

func (e ConversationMessageRemoved) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "removes",
				Type:       "relationship",
				Hint:       "r",
				IsRepeated: false,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "dependsOn",
				Type:       "relationship",
				Hint:       "r",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e ConversationMessageRemoved) ToObject() object.Object {
	d := map[string]interface{}{}
	d["removes:r"] = e.Removes
	if len(e.DependsOn) > 0 {
		d["dependsOn:ar"] = e.DependsOn
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("mochi.io/conversation.MessageRemoved")
	return o
}

func (e *ConversationMessageRemoved) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("removes:r"); v != nil {
		e.Removes = v.PrimitiveHinted().(object.Hash)
	}
	if v := o.Data.Value("dependsOn:ar"); v != nil && v.IsList() {
		// TODO missing implementation for repeated type hint r
	}
	return nil
}
