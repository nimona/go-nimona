// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package chat

import (
	json "encoding/json"

	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
	schema "nimona.io/pkg/schema"
)

type (
	TopicSet struct {
		Stream    *crypto.Hash      `json:"stream:o,omitempty"`
		Topic     string            `json:"topic:s,omitempty"`
		Signature *crypto.Signature `json:"@signature:o,omitempty"`
		Identity  crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
	NameSet struct {
		Stream    *crypto.Hash      `json:"stream:o,omitempty"`
		Name      string            `json:"name:s,omitempty"`
		Signature *crypto.Signature `json:"@signature:o,omitempty"`
		Identity  crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
	ObjectAdded struct {
		Stream    *crypto.Hash      `json:"stream:o,omitempty"`
		Parents   []*crypto.Hash    `json:"parents:ao,omitempty"`
		Body      string            `json:"body:s,omitempty"`
		Signature *crypto.Signature `json:"@signature:o,omitempty"`
		Identity  crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
)

func (e TopicSet) GetType() string {
	return "example/conversation.TopicSet"
}

func (e TopicSet) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "stream",
				Type:       "example/crypto.Hash",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "topic",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e TopicSet) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/conversation.TopicSet"
	if e.Stream != nil {
		m["stream:o"] = e.Stream.ToObject().ToMap()
	}
	if e.Topic != "" {
		m["topic:s"] = e.Topic
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *TopicSet) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e NameSet) GetType() string {
	return "example/conversation.NameSet"
}

func (e NameSet) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "stream",
				Type:       "example/crypto.Hash",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "name",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e NameSet) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/conversation.NameSet"
	if e.Stream != nil {
		m["stream:o"] = e.Stream.ToObject().ToMap()
	}
	if e.Name != "" {
		m["name:s"] = e.Name
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *NameSet) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e ObjectAdded) GetType() string {
	return "example/conversation.objectAdded"
}

func (e ObjectAdded) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "stream",
				Type:       "example/crypto.Hash",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "parents",
				Type:       "example/crypto.Hash",
				Hint:       "o",
				IsRepeated: true,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "body",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e ObjectAdded) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/conversation.objectAdded"
	if e.Stream != nil {
		m["stream:o"] = e.Stream.ToObject().ToMap()
	}
	if len(e.Parents) > 0 {
		m["parents:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Parents))
			for i, v := range e.Parents {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}
	if e.Body != "" {
		m["body:s"] = e.Body
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *ObjectAdded) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
