// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package chat

import (
	"errors"

	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
)

type (
	ConversationStreamRoot struct {
		raw        object.Object
		Stream     object.Hash
		Parents    []object.Hash
		Owners     []crypto.PublicKey
		Policy     object.Policy
		Signatures []object.Signature
		Name       string
	}
	ConversationTopicUpdated struct {
		raw        object.Object
		Stream     object.Hash
		Parents    []object.Hash
		Owners     []crypto.PublicKey
		Policy     object.Policy
		Signatures []object.Signature
		Topic      string
		DependsOn  []object.Hash
	}
	ConversationMessageAdded struct {
		raw        object.Object
		Stream     object.Hash
		Parents    []object.Hash
		Owners     []crypto.PublicKey
		Policy     object.Policy
		Signatures []object.Signature
		Body       string
		DependsOn  []object.Hash
	}
	ConversationMessageRemoved struct {
		raw        object.Object
		Stream     object.Hash
		Parents    []object.Hash
		Owners     []crypto.PublicKey
		Policy     object.Policy
		Signatures []object.Signature
		Removes    object.Hash
		DependsOn  []object.Hash
	}
)

func (e ConversationStreamRoot) GetType() string {
	return "stream:mochi.io/conversation"
}

func (e ConversationStreamRoot) IsStreamRoot() bool {
	return true
}

func (e ConversationStreamRoot) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "name",
			Type:       "string",
			Hint:       "s",
			IsRepeated: false,
			IsOptional: false,
		}},
	}
}

func (e ConversationStreamRoot) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("stream:mochi.io/conversation")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.Name != "" {
		o = o.Set("name:s", e.Name)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *ConversationStreamRoot) FromObject(o object.Object) error {
	content, ok := o.Raw().Value("content:m").(object.Map)
	if !ok {
		return errors.New("missing content")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := content.Value("name:s"); v != nil {
		e.Name = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e ConversationTopicUpdated) GetType() string {
	return "mochi.io/conversation.TopicUpdated"
}

func (e ConversationTopicUpdated) IsStreamRoot() bool {
	return false
}

func (e ConversationTopicUpdated) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "topic",
			Type:       "string",
			Hint:       "s",
			IsRepeated: false,
			IsOptional: false,
		}, {
			Name:       "dependsOn",
			Type:       "relationship",
			Hint:       "r",
			IsRepeated: true,
			IsOptional: false,
		}},
	}
}

func (e ConversationTopicUpdated) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("mochi.io/conversation.TopicUpdated")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.Topic != "" {
		o = o.Set("topic:s", e.Topic)
	}
	if len(e.DependsOn) > 0 {
		v := object.List{}
		for _, iv := range e.DependsOn {
			// TODO missing type hint r, for repeated DependsOn
		}
		o = o.Set("dependsOn:ar", v)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *ConversationTopicUpdated) FromObject(o object.Object) error {
	content, ok := o.Raw().Value("content:m").(object.Map)
	if !ok {
		return errors.New("missing content")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := content.Value("topic:s"); v != nil {
		e.Topic = string(v.PrimitiveHinted().(string))
	}
	if v := content.Value("dependsOn:ar"); v != nil && v.IsList() {
		// TODO missing implementation for repeated type hint r
	}
	return nil
}

func (e ConversationMessageAdded) GetType() string {
	return "mochi.io/conversation.MessageAdded"
}

func (e ConversationMessageAdded) IsStreamRoot() bool {
	return false
}

func (e ConversationMessageAdded) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "body",
			Type:       "string",
			Hint:       "s",
			IsRepeated: false,
			IsOptional: false,
		}, {
			Name:       "dependsOn",
			Type:       "relationship",
			Hint:       "r",
			IsRepeated: true,
			IsOptional: false,
		}},
	}
}

func (e ConversationMessageAdded) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("mochi.io/conversation.MessageAdded")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.Body != "" {
		o = o.Set("body:s", e.Body)
	}
	if len(e.DependsOn) > 0 {
		v := object.List{}
		for _, iv := range e.DependsOn {
			// TODO missing type hint r, for repeated DependsOn
		}
		o = o.Set("dependsOn:ar", v)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *ConversationMessageAdded) FromObject(o object.Object) error {
	content, ok := o.Raw().Value("content:m").(object.Map)
	if !ok {
		return errors.New("missing content")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := content.Value("body:s"); v != nil {
		e.Body = string(v.PrimitiveHinted().(string))
	}
	if v := content.Value("dependsOn:ar"); v != nil && v.IsList() {
		// TODO missing implementation for repeated type hint r
	}
	return nil
}

func (e ConversationMessageRemoved) GetType() string {
	return "mochi.io/conversation.MessageRemoved"
}

func (e ConversationMessageRemoved) IsStreamRoot() bool {
	return false
}

func (e ConversationMessageRemoved) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "removes",
			Type:       "relationship",
			Hint:       "r",
			IsRepeated: false,
			IsOptional: false,
		}, {
			Name:       "dependsOn",
			Type:       "relationship",
			Hint:       "r",
			IsRepeated: true,
			IsOptional: false,
		}},
	}
}

func (e ConversationMessageRemoved) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("mochi.io/conversation.MessageRemoved")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	// TODO missing type hint r, for Removes
	if len(e.DependsOn) > 0 {
		v := object.List{}
		for _, iv := range e.DependsOn {
			// TODO missing type hint r, for repeated DependsOn
		}
		o = o.Set("dependsOn:ar", v)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *ConversationMessageRemoved) FromObject(o object.Object) error {
	content, ok := o.Raw().Value("content:m").(object.Map)
	if !ok {
		return errors.New("missing content")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := content.Value("removes:r"); v != nil {
		e.Removes = v.PrimitiveHinted().(object.Hash)
	}
	if v := content.Value("dependsOn:ar"); v != nil && v.IsList() {
		// TODO missing implementation for repeated type hint r
	}
	return nil
}
