// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package stream

import (
	json "encoding/json"

	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
)

type (
	Policy struct {
		Subjects   []*crypto.PublicKey `json:"subjects:ao,omitempty"`
		Resources  []string            `json:"resources:as,omitempty"`
		Conditions []string            `json:"conditions:as,omitempty"`
		Action     string              `json:"action:s,omitempty"`
	}
	Created struct {
		CreatedDateTime string             `json:"createdDateTime:s,omitempty"`
		PartitionKeys   []string           `json:"partitionKeys:as,omitempty"`
		Policies        []*Policy          `json:"policies:ao,omitempty"`
		Signature       *object.Signature  `json:"_signature:o,omitempty"`
		Owners          []crypto.PublicKey `json:"@owners:as,omitempty"`
	}
	PoliciesUpdated struct {
		Stream    *crypto.Hash       `json:"stream:o,omitempty"`
		Parents   []*crypto.Hash     `json:"parents:ao,omitempty"`
		Policies  []*Policy          `json:"policies:ao,omitempty"`
		Signature *object.Signature  `json:"_signature:o,omitempty"`
		Owners    []crypto.PublicKey `json:"@owners:as,omitempty"`
	}
)

func (e Policy) GetType() string {
	return "example/stream.Policy"
}
func (e Policy) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "subjects",
				Type:       "example/crypto.PublicKey",
				Hint:       "o",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "resources",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "conditions",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "action",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e Policy) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/stream.Policy"
	if len(e.Subjects) > 0 {
		m["subjects:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Subjects))
			for i, v := range e.Subjects {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}
	if len(e.Resources) > 0 {
		m["resources:as"] = e.Resources
	}
	if len(e.Conditions) > 0 {
		m["conditions:as"] = e.Conditions
	}
	if e.Action != "" {
		m["action:s"] = e.Action
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Policy) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e Created) GetType() string {
	return "example/stream.Created"
}
func (e Created) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "createdDateTime",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "partitionKeys",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "policies",
				Type:       "Policy",
				Hint:       "o",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "_signature",
				Type:       "nimona.io/object.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "@owners",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e Created) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/stream.Created"
	if e.CreatedDateTime != "" {
		m["createdDateTime:s"] = e.CreatedDateTime
	}
	if len(e.PartitionKeys) > 0 {
		m["partitionKeys:as"] = e.PartitionKeys
	}
	if len(e.Policies) > 0 {
		m["policies:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Policies))
			for i, v := range e.Policies {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}
	if e.Signature != nil {
		m["_signature:o"] = e.Signature.ToObject().ToMap()
	}
	if len(e.Owners) > 0 {
		m["@owners:as"] = e.Owners
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Created) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e PoliciesUpdated) GetType() string {
	return "example/stream.PoliciesUpdated"
}
func (e PoliciesUpdated) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "stream",
				Type:       "example/crypto.Hash",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "parents",
				Type:       "example/crypto.Hash",
				Hint:       "o",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "policies",
				Type:       "Policy",
				Hint:       "o",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "_signature",
				Type:       "nimona.io/object.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "@owners",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e PoliciesUpdated) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/stream.PoliciesUpdated"
	if e.Stream != nil {
		m["stream:o"] = e.Stream.ToObject().ToMap()
	}
	if len(e.Parents) > 0 {
		m["parents:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Parents))
			for i, v := range e.Parents {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}
	if len(e.Policies) > 0 {
		m["policies:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Policies))
			for i, v := range e.Policies {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}
	if e.Signature != nil {
		m["_signature:o"] = e.Signature.ToObject().ToMap()
	}
	if len(e.Owners) > 0 {
		m["@owners:as"] = e.Owners
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *PoliciesUpdated) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
