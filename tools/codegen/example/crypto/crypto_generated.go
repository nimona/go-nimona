// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package crypto

import (
	json "encoding/json"

	object "nimona.io/pkg/object"
	schema "nimona.io/pkg/schema"
)

type (
	Hash struct {
		HashType string `json:"hashType:s,omitempty"`
		Digest   []byte `json:"digest:d,omitempty"`
	}
	Signature struct {
		PublicKey *PublicKey `json:"publicKey:o,omitempty"`
		Algorithm string     `json:"algorithm:s,omitempty"`
		R         []byte     `json:"r:d,omitempty"`
		S         []byte     `json:"s:d,omitempty"`
	}
	PrivateKey struct {
		PublicKey *PublicKey `json:"publicKey:o,omitempty"`
		KeyType   string     `json:"keyType:s,omitempty"`
		Algorithm string     `json:"algorithm:s,omitempty"`
		Curve     string     `json:"curve:s,omitempty"`
		X         []byte     `json:"x:d,omitempty"`
		Y         []byte     `json:"y:d,omitempty"`
		D         []byte     `json:"d:d,omitempty"`
	}
	PublicKey struct {
		KeyType   string     `json:"keyType:s,omitempty"`
		Algorithm string     `json:"algorithm:s,omitempty"`
		Curve     string     `json:"curve:s,omitempty"`
		X         []byte     `json:"x:d,omitempty"`
		Y         []byte     `json:"y:d,omitempty"`
		Signature *Signature `json:"@signature:o,omitempty"`
	}
)

func (e Hash) GetType() string {
	return "example/crypto.Hash"
}

func (e Hash) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "hashType",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "digest",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e Hash) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/crypto.Hash"
	if e.HashType != "" {
		m["hashType:s"] = e.HashType
	}
	if len(e.Digest) != 0 {
		m["digest:d"] = e.Digest
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Hash) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e Signature) GetType() string {
	return "example/crypto.Signature"
}

func (e Signature) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "publicKey",
				Type:       "PublicKey",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "algorithm",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "r",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "s",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e Signature) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/crypto.Signature"
	if e.PublicKey != nil {
		m["publicKey:o"] = e.PublicKey.ToObject().ToMap()
	}
	if e.Algorithm != "" {
		m["algorithm:s"] = e.Algorithm
	}
	if len(e.R) != 0 {
		m["r:d"] = e.R
	}
	if len(e.S) != 0 {
		m["s:d"] = e.S
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Signature) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e PrivateKey) GetType() string {
	return "example/crypto.PrivateKey"
}

func (e PrivateKey) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "publicKey",
				Type:       "PublicKey",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "keyType",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "algorithm",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "curve",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "x",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "y",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "d",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e PrivateKey) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/crypto.PrivateKey"
	if e.PublicKey != nil {
		m["publicKey:o"] = e.PublicKey.ToObject().ToMap()
	}
	if e.KeyType != "" {
		m["keyType:s"] = e.KeyType
	}
	if e.Algorithm != "" {
		m["algorithm:s"] = e.Algorithm
	}
	if e.Curve != "" {
		m["curve:s"] = e.Curve
	}
	if len(e.X) != 0 {
		m["x:d"] = e.X
	}
	if len(e.Y) != 0 {
		m["y:d"] = e.Y
	}
	if len(e.D) != 0 {
		m["d:d"] = e.D
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *PrivateKey) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e PublicKey) GetType() string {
	return "example/crypto.PublicKey"
}

func (e PublicKey) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "keyType",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "algorithm",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "curve",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "x",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "y",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e PublicKey) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "example/crypto.PublicKey"
	if e.KeyType != "" {
		m["keyType:s"] = e.KeyType
	}
	if e.Algorithm != "" {
		m["algorithm:s"] = e.Algorithm
	}
	if e.Curve != "" {
		m["curve:s"] = e.Curve
	}
	if len(e.X) != 0 {
		m["x:d"] = e.X
	}
	if len(e.Y) != 0 {
		m["y:d"] = e.Y
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *PublicKey) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
