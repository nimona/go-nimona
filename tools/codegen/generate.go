package main

import (
	"bytes"
	"strings"
	"text/template"
)

var primitives = map[string]struct {
	Hint      string
	Type      string
	IsObject  bool
	IsPrimary bool
}{
	"nimona.io/crypto.PrivateKey": {
		Hint:      "s",
		Type:      "crypto.PrivateKey",
		IsObject:  false,
		IsPrimary: true,
	},
	"nimona.io/crypto.PublicKey": {
		Hint:      "s",
		Type:      "crypto.PublicKey",
		IsObject:  false,
		IsPrimary: true,
	},
	"nimona.io/object.Hash": {
		Hint:      "s",
		Type:      "object.Hash",
		IsObject:  false,
		IsPrimary: true,
	},
}

// nolint
var tpl = `// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package {{ .PackageAlias }}

import (
	"fmt"
	{{ range $alias, $pkg := .Imports }}
	{{ $alias }} "{{ $pkg }}"
	{{- end }}
)

type (
	{{- range $object := .Objects }}
	{{ structName $object.Name }} struct {
		{{- range $member := $object.Members }}
			{{- if $member.IsRepeated }}
				{{- if $member.IsObject }}
					{{ $member.Name }} []*{{ memberType $member.Type }} ` + "`" + `json:"{{ memberTag $member.Tag $member.Hint $member.IsRepeated }},omitempty"` + "`" + `
				{{- else }}
					{{ $member.Name }} []{{ memberType $member.Type }} ` + "`" + `json:"{{ memberTag $member.Tag $member.Hint $member.IsRepeated }},omitempty"` + "`" + `
				{{- end }}
			{{- else if $member.IsPrimitive }}
				{{ $member.Name }} {{ memberType $member.Type }} ` + "`" + `json:"{{ memberTag $member.Tag $member.Hint $member.IsRepeated }},omitempty"` + "`" + `
			{{- else if $member.IsObject }}
				{{ $member.Name }} *{{ memberType $member.Type }} ` + "`" + `json:"{{ memberTag $member.Tag $member.Hint $member.IsRepeated }},omitempty"` + "`" + `
			{{- else }}
				{{ $member.Name }} {{ memberType $member.Type }} ` + "`" + `json:"{{ memberTag $member.Tag $member.Hint $member.IsRepeated }},omitempty"` + "`" + `
			{{- end }}
		{{- end }}
	}
	{{- end }}
)

{{ range $object := .Objects }}
func (e {{ structName $object.Name }}) GetType() string {
	return "{{ $object.Name }}"
}

{{ if neq $.Package "nimona.io/schema" }}
func (e {{ structName $object.Name }}) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
		{{- range $member := $object.Members }}
			&schema.Property{
				Name: "{{ $member.Tag }}",
				Type: "{{ $member.SimpleType }}",
				Hint: "{{ $member.Hint }}",
				IsRepeated: {{ if $member.IsRepeated }} true {{ else }} false {{ end }},
				IsOptional: {{ if $member.IsOptional }} true {{ else }} false {{ end }},
			},
		{{- end }}
		},
	}
}
{{ end }}

func (e {{ structName $object.Name }}) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "{{ $object.Name }}"
	{{- range $member := $object.Members }}
		{{- if $member.IsObject }}
			{{- if $member.IsRepeated }}
			if len(e.{{ $member.Name }}) > 0 {
				m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = func() []interface{} {
					a := make([]interface{}, len(e.{{ $member.Name }}))
					for i, v := range e.{{ $member.Name }} {
						a[i] = v.ToObject().ToMap()
					}
					return a
				}()
			}
			{{- else }}
			if e.{{ $member.Name }} != nil {
				m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = e.{{ $member.Name }}.ToObject().ToMap()
			}
			{{- end }}
		{{- else }}
			{{- if $member.IsRepeated }}
				if len(e.{{ $member.Name }}) > 0 {
					m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = e.{{ $member.Name }}
				}
			{{- else }}
				{{- if eq $member.Hint "s" }}
				if e.{{ $member.Name }} != "" {
					m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = e.{{ $member.Name }}
				}
				{{- else if eq $member.Hint "i" }}
				if e.{{ $member.Name }} != 0 {
					m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = e.{{ $member.Name }}
				}
				{{- else if eq $member.Hint "d" }}
				if len(e.{{ $member.Name }}) != 0 {
					m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = e.{{ $member.Name }}
				}
				{{- else if eq $member.Hint "u" }}
				if e.{{ $member.Name }} != 0 {
					m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = e.{{ $member.Name }}
				}
				{{- else if eq $member.Hint "f" }}
				if e.{{ $member.Name }} != 0 {
					m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = e.{{ $member.Name }}
				}
				{{- else }}
				m["{{ memberTag $member.Tag $member.Hint $member.IsRepeated }}"] = e.{{ $member.Name }}
				{{- end }}
			{{- end }}
		{{- end }}
	{{- end }}
	{{- if neq $.Package "nimona.io/schema" }}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	{{- end }}
	return object.Object(m)
}

func (e *{{ structName $object.Name }}) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
{{ end }}
`

func Generate(doc *Document, output string) ([]byte, error) {
	originalImports := map[string]string{}
	t, err := template.New("tpl").Funcs(template.FuncMap{
		"structName": func(name string) string {
			ps := strings.Split(name, "/")
			ps = strings.Split(ps[len(ps)-1], ".")
			if len(ps) == 1 {
				return ucFirst(ps[0])
			}
			if strings.ToLower(ps[len(ps)-2]) == strings.ToLower(doc.PackageAlias) {
				return ucFirst(ps[len(ps)-1])
			}
			return ucFirst(ps[len(ps)-2]) + ucFirst(ps[len(ps)-1])
		},
		"memberType": func(name string) string {
			for alias, pkg := range originalImports {
				name = strings.Replace(name, pkg, alias, 1)
			}
			ps := strings.Split(name, "/")
			return strings.TrimPrefix(ps[len(ps)-1], doc.PackageAlias+".")
		},
		"memberTag": func(tag, hint string, isRepeated bool) string {
			if isRepeated {
				return tag + ":a" + hint
			}
			return tag + ":" + hint
		},
		"neq": func(a, b string) bool {
			return a != b
		},
	}).Parse(tpl)
	if err != nil {
		return nil, err
	}

	// instead of doing the same work for both top-level and stream objects, we
	// convert stream objects into top-level ones

	for _, s := range doc.Streams {
		for _, o := range s.Objects {
			o.Name = s.Name + "." + o.Name
			doc.Objects = append(doc.Objects, o)
		}
	}

	for k, e := range doc.Objects {
		for _, mv := range e.Members {
			for pk, pv := range primitives {
				if strings.HasSuffix(mv.Type, pk) {
					mv.Hint = pv.Hint
					mv.Type = pv.Type
					mv.IsObject = pv.IsObject
					mv.IsPrimitive = pv.IsPrimary
					break
				}
			}
		}
		if e.IsSigned {
			doc.Objects[k].Members = append(
				doc.Objects[k].Members,
				&Member{
					Name:       "Signature",
					Type:       "nimona.io/crypto.Signature",
					SimpleType: "nimona.io/crypto.Signature",
					Tag:        "@signature",
					Hint:       "o",
					IsObject:   true,
				},
				&Member{
					Name:       "Owners",
					Type:       "nimona.io/crypto.PublicKey",
					SimpleType: "nimona.io/crypto.PublicKey",
					Tag:        "@owners",
					Hint:       "s",
					IsRepeated: true,
					IsObject:   false,
				},
			)
		}
	}
	// }

	doc.Imports["json"] = "encoding/json"
	if doc.Package != "nimona.io/object" {
		doc.Imports["object"] = "nimona.io/object"
	}
	if doc.Package != "nimona.io/stream" {
		doc.Imports["stream"] = "nimona.io/stream"
	}
	if doc.Package != "nimona.io/crypto" {
		doc.Imports["crypto"] = "nimona.io/crypto"
	}
	if doc.Package != "nimona.io/schema" {
		doc.Imports["schema"] = "nimona.io/schema"
	}

	for alias, pkg := range doc.Imports {
		originalImports[alias] = pkg
	}

	for i, pkg := range doc.Imports {
		doc.Imports[i] = strings.Replace(pkg, "nimona.io/", "nimona.io/pkg/", 1)
	}

	out := bytes.NewBuffer([]byte{})
	if err := t.Execute(out, doc); err != nil {
		return nil, err
	}

	res := out.String()
	if doc.Package == "nimona.io/object" {
		res = strings.ReplaceAll(res, "object.", "")
	}

	return []byte(res), nil
}

// lastSegment returns the last part of a namespace,
// ie lastSegment(nimona.io/stream) returns stream
func lastSegment(s string) string {
	ps := strings.Split(s, "/")
	return ps[len(ps)-1]
}
