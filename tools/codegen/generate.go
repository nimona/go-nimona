package main

import (
	"bytes"
	"strings"
	"text/template"
)

var primitives = map[string]struct {
	Hint      string
	Type      string
	IsObject  bool
	IsPrimary bool
}{
	"nimona.io/tilde.Digest": {
		Hint:      "r",
		Type:      "tilde.Digest",
		IsObject:  false,
		IsPrimary: true,
	},
}

// nolint
var tpl = `// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package {{ .PackageAlias }}

import (
	"fmt"
	{{ range $alias, $pkg := .Imports }}
	{{ $alias }} "{{ $pkg }}"
	{{- end }}
)

{{- range $object := .Objects }}
const {{ structName $object.Name }}Type = "{{ $object.Name }}"

type {{ structName $object.Name }} struct {
	Metadata object.Metadata {{ tagMetadata $object.Name }}
	{{- range $member := $object.Members }}
		{{- if $member.IsRepeated }}
			{{ $member.Name }} []{{ memberType $member true }} {{ tag $member }}
		{{- else if $member.IsPrimitive }}
			{{ $member.Name }} {{ memberType $member true }} {{ tag $member }}
		{{- else }}
			{{ $member.Name }} {{ memberType $member true}} {{ tag $member }}
		{{- end }}
	{{- end }}
}

{{ end }}
`

func Generate(doc *Document, output string) ([]byte, error) {
	originalImports := map[string]string{}
	t, err := template.New("tpl").Funcs(template.FuncMap{
		"tag": func(m Member) string {
			h := m.Hint
			if m.IsRepeated {
				h = "a" + h
			}
			return "`nimona:\"" + m.Tag + ":" + h + "\"`"
		},
		"tagMetadata": func(name string) string {
			return "`nimona:\"@metadata:m,type=" + name + "\"`"
		},
		"key": func(m Member) string {
			h := m.Hint
			if m.IsRepeated {
				h = "a" + h
			}
			return m.Tag + ":" + h
		},
		"structName": func(name string) string {
			ps := strings.Split(name, "/")
			ps = strings.Split(ps[len(ps)-1], ".")
			nn := ""
			if len(ps) == 1 {
				nn = ucFirst(ps[0])
			} else if strings.ToLower(ps[len(ps)-2]) == strings.ToLower(doc.PackageAlias) {
				nn = ucFirst(ps[len(ps)-1])
			} else {
				nn = ucFirst(ps[len(ps)-2]) + ucFirst(ps[len(ps)-1])
			}
			if strings.HasPrefix(name, "stream:") {
				nn += "StreamRoot"
			}
			return nn
		},
		"memberType": func(m Member, dec bool) string {
			name := m.GoFullType
			for alias, pkg := range originalImports {
				name = strings.Replace(name, pkg, alias, 1)
			}
			ps := strings.Split(name, "/")
			name = strings.TrimPrefix(ps[len(ps)-1], doc.PackageAlias+".")
			if m.IsObject && m.IsOptional {
				if dec {
					name = "*" + name
				} else {
					name = "&" + name
				}
			}
			return name
		},
		"neq": func(a, b string) bool {
			return a != b
		},
		"hp": func(a, b string) bool {
			return strings.HasPrefix(a, b)
		},
		"hnp": func(a, b string) bool {
			return !strings.HasPrefix(a, b)
		},
	}).Parse(tpl)
	if err != nil {
		return nil, err
	}

	// instead of doing the same work for both top-level and stream objects, we
	// convert stream objects into top-level ones

	for _, s := range doc.Streams {
		for _, o := range s.Objects {
			switch {
			case o.IsRoot:
				o.Name = "stream:" + s.Name
			case o.IsEvent:
				o.Name = "event:" + s.Name + "." + o.Name
			default:
				o.Name = s.Name + "." + o.Name
			}
			doc.Objects = append(doc.Objects, o)
		}
	}

	for _, e := range doc.Objects {
		for _, mv := range e.Members {
			for pk, pv := range primitives {
				if strings.HasSuffix(mv.GoFullType, pk) {
					mv.Hint = pv.Hint
					mv.GoFullType = pv.Type
					mv.IsObject = pv.IsObject
					mv.IsPrimitive = pv.IsPrimary
					break
				}
			}
		}
	}

	doc.Imports["json"] = "encoding/json"
	doc.Imports["tilde"] = "nimona.io/tilde"

	if doc.Package != "nimona.io/object" {
		doc.Imports["object"] = "nimona.io/object"
	}
	if doc.Package != "nimona.io/did" {
		doc.Imports["did"] = "nimona.io/did"
	}
	if doc.Package != "nimona.io/stream" {
		doc.Imports["stream"] = "nimona.io/stream"
	}
	if doc.Package != "nimona.io/crypto" {
		doc.Imports["crypto"] = "nimona.io/crypto"
	}
	if doc.Package != "nimona.io/schema" {
		doc.Imports["schema"] = "nimona.io/schema"
	}

	for alias, pkg := range doc.Imports {
		originalImports[alias] = pkg
	}

	for i, pkg := range doc.Imports {
		doc.Imports[i] = strings.Replace(pkg, "nimona.io/", "nimona.io/pkg/", 1)
	}

	out := bytes.NewBuffer([]byte{})
	if err := t.Execute(out, doc); err != nil {
		return nil, err
	}

	res := out.String()
	if doc.Package == "nimona.io/object" {
		res = strings.ReplaceAll(res, "object.", "")
	}

	return []byte(res), nil
}
