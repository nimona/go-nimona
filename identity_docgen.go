// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"

	"nimona.io/internal/tilde"
)

var _ = zero.IsZeroVal
var _ = tilde.NewScanner

func (t *IdentityInfo) Document() *Document {
	return NewDocument(t.Map())
}

func (t *IdentityInfo) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/identity/info"))
	}

	// # t.Alias
	//
	// Type: nimona.IdentityAlias, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Alias) {
			m.Set("alias", t.Alias.Map())
		}
	}

	// # t.Identity
	//
	// Type: nimona.Identity, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Identity) {
			m.Set("identity", t.Identity.Map())
		}
	}

	// # t.PeerAddresses
	//
	// Type: []nimona.PeerAddr, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.PeerAddr, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := tilde.List{}
		for _, v := range t.PeerAddresses {
			if !zero.IsZeroVal(t.PeerAddresses) {
				sm = append(sm, v.Map())
			}
		}
		m.Set("peerAddresses", sm)
	}

	return m
}

func (t *IdentityInfo) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *IdentityInfo) FromMap(d tilde.Map) error {
	*t = IdentityInfo{}

	// # t.Alias
	//
	// Type: nimona.IdentityAlias, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("alias"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := IdentityAlias{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Alias = e
			}
		}
	}

	// # t.Identity
	//
	// Type: nimona.Identity, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("identity"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Identity{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Identity = e
			}
		}
	}

	// # t.PeerAddresses
	//
	// Type: []nimona.PeerAddr, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.PeerAddr, ElemKind: struct, ElemTildeKind: Map
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []PeerAddr{}
		if vs, err := d.Get("peerAddresses"); err == nil {
			if vs, ok := vs.(tilde.List); ok {
				for _, vi := range vs {
					if v, ok := vi.(tilde.Map); ok {
						e := PeerAddr{}
						d := NewDocument(v)
						e.FromDocument(d)
						sm = append(sm, e)
					}
				}
			}
		}
		if len(sm) > 0 {
			t.PeerAddresses = sm
		}
	}

	return nil
}
func (t *Identity) Document() *Document {
	return NewDocument(t.Map())
}

func (t *Identity) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/identity/id"))
	}

	// # t.KeyGraphID
	//
	// Type: nimona.DocumentID, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m.Set("keyGraphID", t.KeyGraphID.Map())
	}

	// # t.Use
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Use) {
			m.Set("type", tilde.String(t.Use))
		}
	}

	return m
}

func (t *Identity) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *Identity) FromMap(d tilde.Map) error {
	*t = Identity{}

	// # t.KeyGraphID
	//
	// Type: nimona.DocumentID, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("keyGraphID"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := DocumentID{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.KeyGraphID = e
			}
		}
	}

	// # t.Use
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("type"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.Use = string(v)
			}
		}
	}

	return nil
}
func (t *IdentityAlias) Document() *Document {
	return NewDocument(t.Map())
}

func (t *IdentityAlias) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/identity.alias"))
	}

	// # t.Hostname
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Hostname) {
			m.Set("hostname", tilde.String(t.Hostname))
		}
	}

	// # t.Path
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Path) {
			m.Set("path", tilde.String(t.Path))
		}
	}

	return m
}

func (t *IdentityAlias) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *IdentityAlias) FromMap(d tilde.Map) error {
	*t = IdentityAlias{}

	// # t.Hostname
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("hostname"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.Hostname = string(v)
			}
		}
	}

	// # t.Path
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("path"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.Path = string(v)
			}
		}
	}

	return nil
}
func (t *KeyGraph) Document() *Document {
	return NewDocument(t.Map())
}

func (t *KeyGraph) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/identity"))
	}

	// # t.Keys
	//
	// Type: nimona.PublicKey, Kind: slice, TildeKind: Bytes
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		m.Set("keys", tilde.Bytes(t.Keys))
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	// # t.Next
	//
	// Type: nimona.PublicKey, Kind: slice, TildeKind: Bytes
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		m.Set("next", tilde.Bytes(t.Next))
	}

	return m
}

func (t *KeyGraph) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *KeyGraph) FromMap(d tilde.Map) error {
	*t = KeyGraph{}

	// # t.Keys
	//
	// Type: nimona.PublicKey, Kind: slice, TildeKind: Bytes
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8, ElemTildeKind: InvalidValueKind0
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get("keys"); err == nil {
			if v, ok := v.(tilde.Bytes); ok {
				t.Keys = PublicKey(v)
			}
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Metadata = e
			}
		}
	}

	// # t.Next
	//
	// Type: nimona.PublicKey, Kind: slice, TildeKind: Bytes
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8, ElemTildeKind: InvalidValueKind0
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get("next"); err == nil {
			if v, ok := v.(tilde.Bytes); ok {
				t.Next = PublicKey(v)
			}
		}
	}

	return nil
}
