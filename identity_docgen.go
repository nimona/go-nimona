// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"
)

var _ = zero.IsZeroVal

func (t *Identity) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/identity/id"
	}

	// # t.KeyGraphID
	//
	// Type: nimona.DocumentID, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m["keyGraphID"] = t.KeyGraphID.DocumentMap()
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	return m
}

func (t *Identity) FromDocumentMap(m DocumentMap) {
	*t = Identity{}

	// # t.KeyGraphID
	//
	// Type: nimona.DocumentID, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["keyGraphID"].(DocumentMap); ok {
			e := DocumentID{}
			e.FromDocumentMap(v)
			t.KeyGraphID = e
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

}
func (t *IdentityAlias) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/identity.alias"
	}

	// # t.Handle
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Handle) {
			m["handle"] = t.Handle
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	// # t.Network
	//
	// Type: nimona.NetworkAlias, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Network) {
			m["network"] = t.Network.DocumentMap()
		}
	}

	return m
}

func (t *IdentityAlias) FromDocumentMap(m DocumentMap) {
	*t = IdentityAlias{}

	// # t.Handle
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["handle"].(string); ok {
			t.Handle = v
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

	// # t.Network
	//
	// Type: nimona.NetworkAlias, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["network"].(DocumentMap); ok {
			e := NetworkAlias{}
			e.FromDocumentMap(v)
			t.Network = e
		}
	}

}
func (t *KeyGraph) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/identity"
	}

	// # t.Keys
	//
	// Type: nimona.PublicKey, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		m["keys"] = []byte(t.Keys)
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	// # t.Next
	//
	// Type: nimona.PublicKey, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		m["next"] = []byte(t.Next)
	}

	return m
}

func (t *KeyGraph) FromDocumentMap(m DocumentMap) {
	*t = KeyGraph{}

	// # t.Keys
	//
	// Type: nimona.PublicKey, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["keys"].([]byte); ok {
			t.Keys = v
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

	// # t.Next
	//
	// Type: nimona.PublicKey, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["next"].([]byte); ok {
			t.Next = v
		}
	}

}
