// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"
)

var _ = zero.IsZeroVal

func (t *DocumentRequest) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/document.request"
	}

	// # t.DocumentID
	//
	// Type: nimona.DocumentID, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m["documentID"] = t.DocumentID.DocumentMap()
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	return m
}

func (t *DocumentRequest) FromDocumentMap(m DocumentMap) {
	*t = DocumentRequest{}

	// # t.DocumentID
	//
	// Type: nimona.DocumentID, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["documentID"].(DocumentMap); ok {
			e := DocumentID{}
			e.FromDocumentMap(v)
			t.DocumentID = e
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

}
func (t *DocumentResponse) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/document.response"
	}

	// # t.Document
	//
	// Type: nimona.DocumentMap, Kind: map
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["document"] = t.Document
	}

	// # t.Error
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Error) {
			m["error"] = t.Error
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.ErrorDescription) {
			m["errorDescription"] = t.ErrorDescription
		}
	}

	// # t.Found
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["found"] = t.Found
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	return m
}

func (t *DocumentResponse) FromDocumentMap(m DocumentMap) {
	*t = DocumentResponse{}

	// # t.Document
	//
	// Type: nimona.DocumentMap, Kind: map
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["document"].(DocumentMap); ok {
			t.Document = v
		} else if v, ok := m["document"].(map[string]any); ok {
			t.Document = DocumentMap(v)
		}
	}

	// # t.Error
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["error"].(bool); ok {
			t.Error = v
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["errorDescription"].(string); ok {
			t.ErrorDescription = v
		}
	}

	// # t.Found
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["found"].(bool); ok {
			t.Found = v
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

}
