// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"

	"nimona.io/internal/tilde"
)

var _ = zero.IsZeroVal
var _ = tilde.NewScanner

func (t *DocumentRequest) Document() *Document {
	return NewDocumentMap(t.Map())
}

func (t *DocumentRequest) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/document.request"))
	}

	// # t.DocumentID
	//
	// Type: nimona.DocumentID, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m.Set("documentID", t.DocumentID.Map())
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	return m
}

func (t *DocumentRequest) FromDocumentMap(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *DocumentRequest) FromMap(d tilde.Map) error {
	*t = DocumentRequest{}

	// # t.DocumentID
	//
	// Type: nimona.DocumentID, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("documentID"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := DocumentID{}
				d := NewDocumentMap(v)
				e.FromDocumentMap(d)
				t.DocumentID = e
			}
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocumentMap(v)
				e.FromDocumentMap(d)
				t.Metadata = e
			}
		}
	}

	return nil
}
func (t *DocumentResponse) Document() *Document {
	return NewDocumentMap(t.Map())
}

func (t *DocumentResponse) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/document.response"))
	}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Error) {
			m.Set("error", tilde.Bool(t.Error))
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.ErrorDescription) {
			m.Set("errorDescription", tilde.String(t.ErrorDescription))
		}
	}

	// # t.Found
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("found", tilde.Bool(t.Found))
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	// # t.Payload
	//
	// Type: nimona.Document, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m.Set("document", t.Payload.Map())
	}

	return m
}

func (t *DocumentResponse) FromDocumentMap(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *DocumentResponse) FromMap(d tilde.Map) error {
	*t = DocumentResponse{}

	// # t.Error
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("error"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Error = bool(v)
			}
		}
	}

	// # t.ErrorDescription
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("errorDescription"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.ErrorDescription = string(v)
			}
		}
	}

	// # t.Found
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("found"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Found = bool(v)
			}
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocumentMap(v)
				e.FromDocumentMap(d)
				t.Metadata = e
			}
		}
	}

	// # t.Payload
	//
	// Type: nimona.Document, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("document"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				t.Payload = *NewDocumentMap(v)
			}
		}
	}

	return nil
}
