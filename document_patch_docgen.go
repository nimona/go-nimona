// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"

	"nimona.io/internal/tilde"
)

var _ = zero.IsZeroVal
var _ = tilde.NewScanner

func (t *DocumentPatch) Document() *Document {
	return NewDocumentMap(t.Map())
}

func (t *DocumentPatch) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/stream/patch"))
	}

	// # t.Dependencies
	//
	// Type: []nimona.DocumentID, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.DocumentID, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.Dependencies) {
			sm := tilde.List{}
			for _, v := range t.Dependencies {
				if !zero.IsZeroVal(t.Dependencies) {
					sm = append(sm, v.Map())
				}
			}
			m.Set("dependencies", sm)
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	// # t.Operations
	//
	// Type: []nimona.DocumentPatchOperation, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.DocumentPatchOperation, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.Operations) {
			sm := tilde.List{}
			for _, v := range t.Operations {
				if !zero.IsZeroVal(t.Operations) {
					sm = append(sm, v.Map())
				}
			}
			m.Set("operations", sm)
		}
	}

	return m
}

func (t *DocumentPatch) FromDocumentMap(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *DocumentPatch) FromMap(d tilde.Map) error {
	*t = DocumentPatch{}

	// # t.Dependencies
	//
	// Type: []nimona.DocumentID, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.DocumentID, ElemKind: struct, ElemTildeKind: Map
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []DocumentID{}
		if vs, err := d.Get("dependencies"); err == nil {
			if vs, ok := vs.(tilde.List); ok {
				for _, vi := range vs {
					if v, ok := vi.(tilde.Map); ok {
						e := DocumentID{}
						d := NewDocumentMap(v)
						e.FromDocumentMap(d)
						sm = append(sm, e)
					}
				}
			}
		}
		if len(sm) > 0 {
			t.Dependencies = sm
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocumentMap(v)
				e.FromDocumentMap(d)
				t.Metadata = e
			}
		}
	}

	// # t.Operations
	//
	// Type: []nimona.DocumentPatchOperation, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.DocumentPatchOperation, ElemKind: struct, ElemTildeKind: Map
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []DocumentPatchOperation{}
		if vs, err := d.Get("operations"); err == nil {
			if vs, ok := vs.(tilde.List); ok {
				for _, vi := range vs {
					if v, ok := vi.(tilde.Map); ok {
						e := DocumentPatchOperation{}
						d := NewDocumentMap(v)
						e.FromDocumentMap(d)
						sm = append(sm, e)
					}
				}
			}
		}
		if len(sm) > 0 {
			t.Operations = sm
		}
	}

	return nil
}
func (t *DocumentPatchOperation) Document() *Document {
	return NewDocumentMap(t.Map())
}

func (t *DocumentPatchOperation) Map() tilde.Map {
	m := tilde.Map{}

	// # t.From
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.From) {
			m.Set("from", tilde.String(t.From))
		}
	}

	// # t.Op
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("op", tilde.String(t.Op))
	}

	// # t.Path
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("path", tilde.String(t.Path))
	}

	// # t.Value
	//
	// Type: nimona.Document, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Value) {
			m.Set("value", t.Value.Map())
		}
	}

	return m
}

func (t *DocumentPatchOperation) FromDocumentMap(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *DocumentPatchOperation) FromMap(d tilde.Map) error {
	*t = DocumentPatchOperation{}

	// # t.From
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("from"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.From = string(v)
			}
		}
	}

	// # t.Op
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("op"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.Op = string(v)
			}
		}
	}

	// # t.Path
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("path"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.Path = string(v)
			}
		}
	}

	// # t.Value
	//
	// Type: nimona.Document, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("value"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				t.Value = *NewDocumentMap(v)
			}
		}
	}

	return nil
}
