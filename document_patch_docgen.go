// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"
)

var _ = zero.IsZeroVal

func (t *DocumentPatch) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/stream/patch"
	}

	// # t.Dependencies
	//
	// Type: []nimona.DocumentID, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.DocumentID, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.Dependencies) {
			sm := []any{}
			for _, v := range t.Dependencies {
				if !zero.IsZeroVal(t.Dependencies) {
					sm = append(sm, v.DocumentMap())
				}
			}
			m["dependencies"] = sm
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	// # t.Operations
	//
	// Type: []nimona.DocumentPatchOperation, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.DocumentPatchOperation, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.Operations) {
			sm := []any{}
			for _, v := range t.Operations {
				if !zero.IsZeroVal(t.Operations) {
					sm = append(sm, v.DocumentMap())
				}
			}
			m["operations"] = sm
		}
	}

	return m
}

func (t *DocumentPatch) FromDocumentMap(m DocumentMap) {
	*t = DocumentPatch{}

	// # t.Dependencies
	//
	// Type: []nimona.DocumentID, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.DocumentID, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []DocumentID{}
		if vs, ok := m["dependencies"].([]any); ok {
			for _, vi := range vs {
				v, ok := vi.(DocumentMap)
				if ok {
					e := DocumentID{}
					e.FromDocumentMap(v)
					sm = append(sm, e)
				}
			}
		}
		if len(sm) > 0 {
			t.Dependencies = sm
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

	// # t.Operations
	//
	// Type: []nimona.DocumentPatchOperation, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.DocumentPatchOperation, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []DocumentPatchOperation{}
		if vs, ok := m["operations"].([]any); ok {
			for _, vi := range vs {
				v, ok := vi.(DocumentMap)
				if ok {
					e := DocumentPatchOperation{}
					e.FromDocumentMap(v)
					sm = append(sm, e)
				}
			}
		}
		if len(sm) > 0 {
			t.Operations = sm
		}
	}

}
func (t *DocumentPatchOperation) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.From
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.From) {
			m["from"] = t.From
		}
	}

	// # t.Op
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["op"] = t.Op
	}

	// # t.Path
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["path"] = t.Path
	}

	// # t.Value
	//
	// Type: nimona.DocumentMap, Kind: map
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Value) {
			m["value"] = t.Value
		}
	}

	return m
}

func (t *DocumentPatchOperation) FromDocumentMap(m DocumentMap) {
	*t = DocumentPatchOperation{}

	// # t.From
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["from"].(string); ok {
			t.From = v
		}
	}

	// # t.Op
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["op"].(string); ok {
			t.Op = v
		}
	}

	// # t.Path
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["path"].(string); ok {
			t.Path = v
		}
	}

	// # t.Value
	//
	// Type: nimona.DocumentMap, Kind: map
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["value"].(DocumentMap); ok {
			t.Value = v
		} else if v, ok := m["value"].(map[string]any); ok {
			t.Value = DocumentMap(v)
		}
	}

}
