// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"
)

var _ = zero.IsZeroVal

func (t *DocumentBase) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	// # t.Type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = t.Type
	}

	return m
}

func (t *DocumentBase) FromDocumentMap(m DocumentMap) {
	*t = DocumentBase{}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

	// # t.Type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["$type"].(string); ok {
			t.Type = v
		}
	}

}
func (t *Metadata) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.Owner
	//
	// Type: nimona.Identity, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: true
	{
		if !zero.IsZeroVal(t.Owner) {
			m["owner"] = t.Owner.DocumentMap()
		}
	}

	// # t.Permissions
	//
	// Type: []nimona.Permissions, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.Permissions, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.Permissions) {
			sm := []any{}
			for _, v := range t.Permissions {
				if !zero.IsZeroVal(t.Permissions) {
					sm = append(sm, v.DocumentMap())
				}
			}
			m["permissions"] = sm
		}
	}

	// # t.Signature
	//
	// Type: nimona.Signature, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: true
	{
		if !zero.IsZeroVal(t.Signature) {
			m["_signature"] = t.Signature.DocumentMap()
		}
	}

	// # t.Timestamp
	//
	// Type: uint, Kind: uint
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Timestamp) {
			m["timestamp"] = t.Timestamp
		}
	}

	return m
}

func (t *Metadata) FromDocumentMap(m DocumentMap) {
	*t = Metadata{}

	// # t.Owner
	//
	// Type: nimona.Identity, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: true
	{
		if v, ok := m["owner"].(DocumentMap); ok {
			e := Identity{}
			e.FromDocumentMap(v)
			t.Owner = &e
		}
	}

	// # t.Permissions
	//
	// Type: []nimona.Permissions, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.Permissions, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []Permissions{}
		if vs, ok := m["permissions"].([]any); ok {
			for _, vi := range vs {
				v, ok := vi.(DocumentMap)
				if ok {
					e := Permissions{}
					e.FromDocumentMap(v)
					sm = append(sm, e)
				}
			}
		}
		if len(sm) > 0 {
			t.Permissions = sm
		}
	}

	// # t.Signature
	//
	// Type: nimona.Signature, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: true
	{
		if v, ok := m["_signature"].(DocumentMap); ok {
			e := Signature{}
			e.FromDocumentMap(v)
			t.Signature = &e
		}
	}

	// # t.Timestamp
	//
	// Type: uint, Kind: uint
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		// TODO: Unsupported type uint
	}

}
func (t *Permissions) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.Conditions
	//
	// Type: nimona.PermissionsCondition, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m["conditions"] = t.Conditions.DocumentMap()
	}

	// # t.Operations
	//
	// Type: nimona.PermissionsAllow, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m["operations"] = t.Operations.DocumentMap()
	}

	// # t.Paths
	//
	// Type: []string, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: string, ElemKind: string
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		s := make([]any, len(t.Paths))
		for i, v := range t.Paths {
			s[i] = v
		}
		m["paths"] = s
	}

	return m
}

func (t *Permissions) FromDocumentMap(m DocumentMap) {
	*t = Permissions{}

	// # t.Conditions
	//
	// Type: nimona.PermissionsCondition, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["conditions"].(DocumentMap); ok {
			e := PermissionsCondition{}
			e.FromDocumentMap(v)
			t.Conditions = e
		}
	}

	// # t.Operations
	//
	// Type: nimona.PermissionsAllow, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["operations"].(DocumentMap); ok {
			e := PermissionsAllow{}
			e.FromDocumentMap(v)
			t.Operations = e
		}
	}

	// # t.Paths
	//
	// Type: []string, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: string, ElemKind: string
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["paths"].([]any); ok {
			s := make([]string, len(v))
			for i, vi := range v {
				s[i] = vi.(string)
			}
			t.Paths = s
		}
	}

}
func (t *PermissionsAllow) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.Add
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Add) {
			m["add"] = t.Add
		}
	}

	// # t.Copy
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Copy) {
			m["copy"] = t.Copy
		}
	}

	// # t.Move
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Move) {
			m["move"] = t.Move
		}
	}

	// # t.Read
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Read) {
			m["read"] = t.Read
		}
	}

	// # t.Remove
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Remove) {
			m["remove"] = t.Remove
		}
	}

	// # t.Replace
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Replace) {
			m["replace"] = t.Replace
		}
	}

	// # t.Test
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Test) {
			m["test"] = t.Test
		}
	}

	return m
}

func (t *PermissionsAllow) FromDocumentMap(m DocumentMap) {
	*t = PermissionsAllow{}

	// # t.Add
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["add"].(bool); ok {
			t.Add = v
		}
	}

	// # t.Copy
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["copy"].(bool); ok {
			t.Copy = v
		}
	}

	// # t.Move
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["move"].(bool); ok {
			t.Move = v
		}
	}

	// # t.Read
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["read"].(bool); ok {
			t.Read = v
		}
	}

	// # t.Remove
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["remove"].(bool); ok {
			t.Remove = v
		}
	}

	// # t.Replace
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["replace"].(bool); ok {
			t.Replace = v
		}
	}

	// # t.Test
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["test"].(bool); ok {
			t.Test = v
		}
	}

}
func (t *PermissionsCondition) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.IsOwner
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.IsOwner) {
			m["isOwner"] = t.IsOwner
		}
	}

	return m
}

func (t *PermissionsCondition) FromDocumentMap(m DocumentMap) {
	*t = PermissionsCondition{}

	// # t.IsOwner
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["isOwner"].(bool); ok {
			t.IsOwner = v
		}
	}

}
func (t *Signature) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.Signer
	//
	// Type: nimona.PeerKey, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m["signer"] = t.Signer.DocumentMap()
	}

	// # t.X
	//
	// Type: []uint8, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		m["x"] = []byte(t.X)
	}

	return m
}

func (t *Signature) FromDocumentMap(m DocumentMap) {
	*t = Signature{}

	// # t.Signer
	//
	// Type: nimona.PeerKey, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["signer"].(DocumentMap); ok {
			e := PeerKey{}
			e.FromDocumentMap(v)
			t.Signer = e
		}
	}

	// # t.X
	//
	// Type: []uint8, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["x"].([]byte); ok {
			t.X = v
		}
	}

}
