// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package identity

import (
	json "encoding/json"

	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
	schema "nimona.io/pkg/schema"
)

type (
	Contact struct {
		Alias          string            `json:"alias:s,omitempty"`
		PublicKey      crypto.PublicKey  `json:"publicKey:s,omitempty"`
		CreateDatetime string            `json:"createDatetime:s,omitempty"`
		Signature      *crypto.Signature `json:"@signature:o,omitempty"`
		Identity       crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
	Profile struct {
		DisplayPicture []byte            `json:"displayPicture:d,omitempty"`
		NameFirst      string            `json:"nameFirst:s,omitempty"`
		NameLast       string            `json:"nameLast:s,omitempty"`
		Version        int64             `json:"version:i,omitempty"`
		Signature      *crypto.Signature `json:"@signature:o,omitempty"`
		Identity       crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
)

func (e Contact) GetType() string {
	return "nimona.io/identity.Contact"
}

func (e Contact) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "alias",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "publicKey",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "createDatetime",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e Contact) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/identity.Contact"
	if e.Alias != "" {
		m["alias:s"] = e.Alias
	}
	if e.PublicKey != "" {
		m["publicKey:s"] = e.PublicKey
	}
	if e.CreateDatetime != "" {
		m["createDatetime:s"] = e.CreateDatetime
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Contact) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e Profile) GetType() string {
	return "nimona.io/identity.Profile"
}

func (e Profile) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "displayPicture",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "nameFirst",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "nameLast",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "version",
				Type:       "int",
				Hint:       "i",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e Profile) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/identity.Profile"
	if len(e.DisplayPicture) != 0 {
		m["displayPicture:d"] = e.DisplayPicture
	}
	if e.NameFirst != "" {
		m["nameFirst:s"] = e.NameFirst
	}
	if e.NameLast != "" {
		m["nameLast:s"] = e.NameLast
	}
	if e.Version != 0 {
		m["version:i"] = e.Version
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Profile) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
