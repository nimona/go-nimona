// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/geoah/genny

package connmanager

import (
	"sync"

	"nimona.io/pkg/crypto"
)

type (
	connections string // nolint
	// ConnectionsMap -
	ConnectionsMap struct {
		m sync.Map
	}
)

// NewConnectionsMap constructs a new SyncMap
func NewConnectionsMap() *ConnectionsMap {
	return &ConnectionsMap{}
}

// GetOrPut -
func (m *ConnectionsMap) GetOrPut(k *crypto.PublicKey, v *peerbox) (*peerbox, bool) {
	nv, ok := m.m.LoadOrStore(k.String(), v)
	return nv.(*peerbox), ok
}

// Put -
func (m *ConnectionsMap) Put(k *crypto.PublicKey, v *peerbox) {
	m.m.Store(k.String(), v)
}

// Get -
func (m *ConnectionsMap) Get(k *crypto.PublicKey) (*peerbox, bool) {
	i, ok := m.m.Load(k.String())
	if !ok {
		return nil, false
	}

	v, ok := i.(*peerbox)
	if !ok {
		return nil, false
	}

	return v, true
}

// Delete -
func (m *ConnectionsMap) Delete(k *crypto.PublicKey) {
	m.m.Delete(k.String())
}

// Range -
func (m *ConnectionsMap) Range(i func(k *crypto.PublicKey, v *peerbox) bool) {
	m.m.Range(func(k, v interface{}) bool {
		kk := &crypto.PublicKey{}
		if err := kk.UnmarshalString(k.(string)); err != nil {
			panic(err)
		}
		return i(kk, v.(*peerbox))
	})
}

// ListKeys -
func (m *ConnectionsMap) ListKeys() []*crypto.PublicKey {
	vs := []*crypto.PublicKey{}
	m.m.Range(func(k, v interface{}) bool {
		kk := &crypto.PublicKey{}
		if err := kk.UnmarshalString(k.(string)); err != nil {
			panic(err)
		}
		vs = append(vs, kk)
		return true
	})
	return vs
}

// ListValues -
func (m *ConnectionsMap) ListValues() []*peerbox {
	vs := []*peerbox{}
	m.m.Range(func(k, v interface{}) bool {
		vs = append(vs, v.(*peerbox))
		return true
	})
	return vs
}
