// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package fixtures

import (
	object "nimona.io/pkg/object"
)

type (
	TestPolicy struct {
		Metadata   object.Metadata `nimona:"metadata:m,omitempty"`
		Subjects   []string        `nimona:"subjects:as,omitempty"`
		Resources  []string        `nimona:"resources:as,omitempty"`
		Conditions []string        `nimona:"conditions:as,omitempty"`
		Action     string          `nimona:"action:s,omitempty"`
	}
	TestStream struct {
		Metadata        object.Metadata `nimona:"metadata:m,omitempty"`
		Nonce           string          `nimona:"nonce:s,omitempty"`
		CreatedDateTime string          `nimona:"createdDateTime:s,omitempty"`
	}
	TestSubscribed struct {
		Metadata object.Metadata `nimona:"metadata:m,omitempty"`
		Nonce    string          `nimona:"nonce:s,omitempty"`
	}
	TestUnsubscribed struct {
		Metadata object.Metadata `nimona:"metadata:m,omitempty"`
		Nonce    string          `nimona:"nonce:s,omitempty"`
	}
	TestRequest struct {
		Metadata  object.Metadata `nimona:"metadata:m,omitempty"`
		RequestID string          `nimona:"requestID:s,omitempty"`
		Foo       string          `nimona:"foo:s,omitempty"`
	}
	TestResponse struct {
		Metadata  object.Metadata `nimona:"metadata:m,omitempty"`
		RequestID string          `nimona:"requestID:s,omitempty"`
		Foo       string          `nimona:"foo:s,omitempty"`
	}
)

func (e *TestPolicy) Type() string {
	return "nimona.io/fixtures.TestPolicy"
}

func (e TestPolicy) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestPolicy",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// if $member.IsRepeated
	if len(e.Subjects) > 0 {
		// else
		// r.Data["subjects"] = object.ToStringArray(e.Subjects)
		rv := make(object.StringArray, len(e.Subjects))
		for i, iv := range e.Subjects {
			rv[i] = object.String(iv)
		}
		r.Data["subjects"] = rv
	}
	// if $member.IsRepeated
	if len(e.Resources) > 0 {
		// else
		// r.Data["resources"] = object.ToStringArray(e.Resources)
		rv := make(object.StringArray, len(e.Resources))
		for i, iv := range e.Resources {
			rv[i] = object.String(iv)
		}
		r.Data["resources"] = rv
	}
	// if $member.IsRepeated
	if len(e.Conditions) > 0 {
		// else
		// r.Data["conditions"] = object.ToStringArray(e.Conditions)
		rv := make(object.StringArray, len(e.Conditions))
		for i, iv := range e.Conditions {
			rv[i] = object.String(iv)
		}
		r.Data["conditions"] = rv
	}
	// else
	// r.Data["action"] = object.String(e.Action)
	r.Data["action"] = object.String(e.Action)
	return r
}

func (e *TestPolicy) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["subjects"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.Subjects = rv
		}
	}
	if v, ok := o.Data["resources"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.Resources = rv
		}
	}
	if v, ok := o.Data["conditions"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.Conditions = rv
		}
	}
	if v, ok := o.Data["action"]; ok {
		if t, ok := v.(object.String); ok {
			e.Action = string(t)
		}
	}
	return nil
}

func (e *TestStream) Type() string {
	return "nimona.io/fixtures.TestStream"
}

func (e TestStream) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestStream",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["nonce"] = object.String(e.Nonce)
	r.Data["nonce"] = object.String(e.Nonce)
	// else
	// r.Data["createdDateTime"] = object.String(e.CreatedDateTime)
	r.Data["createdDateTime"] = object.String(e.CreatedDateTime)
	return r
}

func (e *TestStream) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["nonce"]; ok {
		if t, ok := v.(object.String); ok {
			e.Nonce = string(t)
		}
	}
	if v, ok := o.Data["createdDateTime"]; ok {
		if t, ok := v.(object.String); ok {
			e.CreatedDateTime = string(t)
		}
	}
	return nil
}

func (e *TestSubscribed) Type() string {
	return "nimona.io/fixtures.TestSubscribed"
}

func (e TestSubscribed) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestSubscribed",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["nonce"] = object.String(e.Nonce)
	r.Data["nonce"] = object.String(e.Nonce)
	return r
}

func (e *TestSubscribed) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["nonce"]; ok {
		if t, ok := v.(object.String); ok {
			e.Nonce = string(t)
		}
	}
	return nil
}

func (e *TestUnsubscribed) Type() string {
	return "nimona.io/fixtures.TestUnsubscribed"
}

func (e TestUnsubscribed) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestUnsubscribed",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["nonce"] = object.String(e.Nonce)
	r.Data["nonce"] = object.String(e.Nonce)
	return r
}

func (e *TestUnsubscribed) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["nonce"]; ok {
		if t, ok := v.(object.String); ok {
			e.Nonce = string(t)
		}
	}
	return nil
}

func (e *TestRequest) Type() string {
	return "nimona.io/fixtures.TestRequest"
}

func (e TestRequest) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestRequest",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["requestID"] = object.String(e.RequestID)
	r.Data["requestID"] = object.String(e.RequestID)
	// else
	// r.Data["foo"] = object.String(e.Foo)
	r.Data["foo"] = object.String(e.Foo)
	return r
}

func (e *TestRequest) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["requestID"]; ok {
		if t, ok := v.(object.String); ok {
			e.RequestID = string(t)
		}
	}
	if v, ok := o.Data["foo"]; ok {
		if t, ok := v.(object.String); ok {
			e.Foo = string(t)
		}
	}
	return nil
}

func (e *TestResponse) Type() string {
	return "nimona.io/fixtures.TestResponse"
}

func (e TestResponse) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestResponse",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["requestID"] = object.String(e.RequestID)
	r.Data["requestID"] = object.String(e.RequestID)
	// else
	// r.Data["foo"] = object.String(e.Foo)
	r.Data["foo"] = object.String(e.Foo)
	return r
}

func (e *TestResponse) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["requestID"]; ok {
		if t, ok := v.(object.String); ok {
			e.RequestID = string(t)
		}
	}
	if v, ok := o.Data["foo"]; ok {
		if t, ok := v.(object.String); ok {
			e.Foo = string(t)
		}
	}
	return nil
}
