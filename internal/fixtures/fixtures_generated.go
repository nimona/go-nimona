// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package fixtures

import (
	object "nimona.io/pkg/object"
)

type (
	TestPolicy struct {
		Metadata   object.Metadata `nimona:"metadata:m,omitempty"`
		Subjects   []string        `nimona:"subjects:as,omitempty"`
		Resources  []string        `nimona:"resources:as,omitempty"`
		Conditions []string        `nimona:"conditions:as,omitempty"`
		Action     string          `nimona:"action:s,omitempty"`
	}
	TestStream struct {
		Metadata        object.Metadata `nimona:"metadata:m,omitempty"`
		Nonce           string          `nimona:"nonce:s,omitempty"`
		CreatedDateTime string          `nimona:"createdDateTime:s,omitempty"`
	}
	TestSubscribed struct {
		Metadata object.Metadata `nimona:"metadata:m,omitempty"`
		Nonce    string          `nimona:"nonce:s,omitempty"`
	}
	TestUnsubscribed struct {
		Metadata object.Metadata `nimona:"metadata:m,omitempty"`
		Nonce    string          `nimona:"nonce:s,omitempty"`
	}
	TestRequest struct {
		Metadata  object.Metadata `nimona:"metadata:m,omitempty"`
		RequestID string          `nimona:"requestID:s,omitempty"`
		Foo       string          `nimona:"foo:s,omitempty"`
	}
	TestResponse struct {
		Metadata  object.Metadata `nimona:"metadata:m,omitempty"`
		RequestID string          `nimona:"requestID:s,omitempty"`
		Foo       string          `nimona:"foo:s,omitempty"`
	}
)

func (e *TestPolicy) Type() string {
	return "nimona.io/fixtures.TestPolicy"
}

func (e TestPolicy) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestPolicy",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	if len(e.Subjects) > 0 {
		r.Data["subjects:as"] = e.Subjects
	}
	if len(e.Resources) > 0 {
		r.Data["resources:as"] = e.Resources
	}
	if len(e.Conditions) > 0 {
		r.Data["conditions:as"] = e.Conditions
	}
	r.Data["action:s"] = e.Action
	return r
}

func (e TestPolicy) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	if len(e.Subjects) > 0 {
		d["subjects:as"] = e.Subjects
	}
	if len(e.Resources) > 0 {
		d["resources:as"] = e.Resources
	}
	if len(e.Conditions) > 0 {
		d["conditions:as"] = e.Conditions
	}
	d["action:s"] = e.Action
	r := map[string]interface{}{
		"type:s":     "nimona.io/fixtures.TestPolicy",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *TestPolicy) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *TestStream) Type() string {
	return "nimona.io/fixtures.TestStream"
}

func (e TestStream) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestStream",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["nonce:s"] = e.Nonce
	r.Data["createdDateTime:s"] = e.CreatedDateTime
	return r
}

func (e TestStream) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	d["nonce:s"] = e.Nonce
	d["createdDateTime:s"] = e.CreatedDateTime
	r := map[string]interface{}{
		"type:s":     "nimona.io/fixtures.TestStream",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *TestStream) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *TestSubscribed) Type() string {
	return "nimona.io/fixtures.TestSubscribed"
}

func (e TestSubscribed) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestSubscribed",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["nonce:s"] = e.Nonce
	return r
}

func (e TestSubscribed) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	d["nonce:s"] = e.Nonce
	r := map[string]interface{}{
		"type:s":     "nimona.io/fixtures.TestSubscribed",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *TestSubscribed) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *TestUnsubscribed) Type() string {
	return "nimona.io/fixtures.TestUnsubscribed"
}

func (e TestUnsubscribed) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestUnsubscribed",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["nonce:s"] = e.Nonce
	return r
}

func (e TestUnsubscribed) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	d["nonce:s"] = e.Nonce
	r := map[string]interface{}{
		"type:s":     "nimona.io/fixtures.TestUnsubscribed",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *TestUnsubscribed) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *TestRequest) Type() string {
	return "nimona.io/fixtures.TestRequest"
}

func (e TestRequest) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestRequest",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["requestID:s"] = e.RequestID
	r.Data["foo:s"] = e.Foo
	return r
}

func (e TestRequest) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	d["requestID:s"] = e.RequestID
	d["foo:s"] = e.Foo
	r := map[string]interface{}{
		"type:s":     "nimona.io/fixtures.TestRequest",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *TestRequest) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *TestResponse) Type() string {
	return "nimona.io/fixtures.TestResponse"
}

func (e TestResponse) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/fixtures.TestResponse",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["requestID:s"] = e.RequestID
	r.Data["foo:s"] = e.Foo
	return r
}

func (e TestResponse) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	d["requestID:s"] = e.RequestID
	d["foo:s"] = e.Foo
	r := map[string]interface{}{
		"type:s":     "nimona.io/fixtures.TestResponse",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *TestResponse) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}
