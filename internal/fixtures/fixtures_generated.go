// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package fixtures

import (
	"nimona.io/pkg/immutable"
	object "nimona.io/pkg/object"
)

type (
	TestPolicy struct {
		Header     object.Header
		Subjects   []string
		Resources  []string
		Conditions []string
		Action     string
	}
	TestStream struct {
		Header          object.Header
		Nonce           string
		CreatedDateTime string
	}
	TestSubscribed struct {
		Header object.Header
		Nonce  string
	}
	TestUnsubscribed struct {
		Header object.Header
		Nonce  string
	}
)

func (e TestPolicy) GetType() string {
	return "nimona.io/fixtures.TestPolicy"
}

func (e TestPolicy) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "subjects",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "resources",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "conditions",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "action",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e TestPolicy) ToObject() object.Object {
	d := map[string]interface{}{}
	if len(e.Subjects) > 0 {
		d["subjects:as"] = e.Subjects
	}
	if len(e.Resources) > 0 {
		d["resources:as"] = e.Resources
	}
	if len(e.Conditions) > 0 {
		d["conditions:as"] = e.Conditions
	}
	if e.Action != "" {
		d["action:s"] = e.Action
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/fixtures.TestPolicy")
	return o
}

func (e *TestPolicy) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("subjects:as"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]string)
		e.Subjects = make([]string, len(m))
		for i, iv := range m {
			e.Subjects[i] = string(iv)
		}
	}
	if v := o.Data.Value("resources:as"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]string)
		e.Resources = make([]string, len(m))
		for i, iv := range m {
			e.Resources[i] = string(iv)
		}
	}
	if v := o.Data.Value("conditions:as"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]string)
		e.Conditions = make([]string, len(m))
		for i, iv := range m {
			e.Conditions[i] = string(iv)
		}
	}
	if v := o.Data.Value("action:s"); v != nil {
		e.Action = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e TestStream) GetType() string {
	return "nimona.io/fixtures.TestStream"
}

func (e TestStream) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&object.SchemaProperty{
				Name:       "createdDateTime",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e TestStream) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Nonce != "" {
		d["nonce:s"] = e.Nonce
	}
	if e.CreatedDateTime != "" {
		d["createdDateTime:s"] = e.CreatedDateTime
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/fixtures.TestStream")
	return o
}

func (e *TestStream) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("nonce:s"); v != nil {
		e.Nonce = string(v.PrimitiveHinted().(string))
	}
	if v := o.Data.Value("createdDateTime:s"); v != nil {
		e.CreatedDateTime = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e TestSubscribed) GetType() string {
	return "nimona.io/fixtures.TestSubscribed"
}

func (e TestSubscribed) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e TestSubscribed) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Nonce != "" {
		d["nonce:s"] = e.Nonce
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/fixtures.TestSubscribed")
	return o
}

func (e *TestSubscribed) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("nonce:s"); v != nil {
		e.Nonce = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e TestUnsubscribed) GetType() string {
	return "nimona.io/fixtures.TestUnsubscribed"
}

func (e TestUnsubscribed) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e TestUnsubscribed) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Nonce != "" {
		d["nonce:s"] = e.Nonce
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/fixtures.TestUnsubscribed")
	return o
}

func (e *TestUnsubscribed) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("nonce:s"); v != nil {
		e.Nonce = string(v.PrimitiveHinted().(string))
	}
	return nil
}
