// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"

	"nimona.io/internal/tilde"
)

var _ = zero.IsZeroVal
var _ = tilde.NewScanner

func (t *PeerCapabilitiesRequest) Document() *Document {
	return NewDocument(t.Map())
}

func (t *PeerCapabilitiesRequest) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/peer/capabilities.request"))
	}

	return m
}

func (t *PeerCapabilitiesRequest) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *PeerCapabilitiesRequest) FromMap(d tilde.Map) error {
	*t = PeerCapabilitiesRequest{}

	return nil
}
func (t *PeerCapabilitiesResponse) Document() *Document {
	return NewDocument(t.Map())
}

func (t *PeerCapabilitiesResponse) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("core/peer/capabilities.response"))
	}

	// # t.Capabilities
	//
	// Type: []string, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: string, ElemKind: string
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		s := make(tilde.List, len(t.Capabilities))
		for i, v := range t.Capabilities {
			s[i] = tilde.String(v)
		}
		m.Set("", s)
	}

	return m
}

func (t *PeerCapabilitiesResponse) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *PeerCapabilitiesResponse) FromMap(d tilde.Map) error {
	*t = PeerCapabilitiesResponse{}

	// # t.Capabilities
	//
	// Type: []string, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: string, ElemKind: string, ElemTildeKind: String
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get(""); err == nil {
			if v, ok := v.(tilde.List); ok {
				s := make([]string, len(v))
				for i, vi := range v {
					if vi, ok := vi.(tilde.String); ok {
						s[i] = string(vi)
					}
				}
				t.Capabilities = s
			}
		}
	}

	return nil
}
