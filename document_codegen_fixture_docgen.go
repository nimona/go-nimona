// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"
)

var _ = zero.IsZeroVal

func (t *codegenFixture) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "foo"
	}

	// # t.Bool
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Bool) {
			m["bool"] = t.Bool
		}
	}

	// # t.Bytes
	//
	// Type: []uint8, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.Bytes) {
			m["bytes"] = []byte(t.Bytes)
		}
	}

	// # t.Int64
	//
	// Type: int64, Kind: int64
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Int64) {
			m["int64"] = t.Int64
		}
	}

	// # t.MapPtr
	//
	// Type: nimona.codegenFixture, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: true
	{
		if !zero.IsZeroVal(t.MapPtr) {
			m["mapPtr"] = t.MapPtr.DocumentMap()
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	// # t.RepeatedBool
	//
	// Type: []bool, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: bool, ElemKind: bool
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedBool) {
			s := make([]any, len(t.RepeatedBool))
			for i, v := range t.RepeatedBool {
				s[i] = v
			}
			m["repeatedbool"] = s
		}
	}

	// # t.RepeatedBytes
	//
	// Type: [][]uint8, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: []uint8, ElemKind: slice
	// IsElemSlice: true, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedBytes) {
			s := make([]any, len(t.RepeatedBytes))
			for i, v := range t.RepeatedBytes {
				s[i] = v
			}
			m["repeatedbytes"] = s
		}
	}

	// # t.RepeatedInt64
	//
	// Type: []int64, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: int64, ElemKind: int64
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedInt64) {
			s := make([]any, len(t.RepeatedInt64))
			for i, v := range t.RepeatedInt64 {
				s[i] = v
			}
			m["repeatedint64"] = s
		}
	}

	// # t.RepeatedMap
	//
	// Type: []nimona.codegenFixture, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.codegenFixture, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedMap) {
			sm := []any{}
			for _, v := range t.RepeatedMap {
				if !zero.IsZeroVal(t.RepeatedMap) {
					sm = append(sm, v.DocumentMap())
				}
			}
			m["repeatedmap"] = sm
		}
	}

	// # t.RepeatedMapPtr
	//
	// Type: []*nimona.codegenFixture, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.codegenFixture, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: true
	{
		if !zero.IsZeroVal(t.RepeatedMapPtr) {
			sm := []any{}
			for _, v := range t.RepeatedMapPtr {
				if !zero.IsZeroVal(t.RepeatedMapPtr) {
					sm = append(sm, v.DocumentMap())
				}
			}
			m["repeatedmapPtr"] = sm
		}
	}

	// # t.RepeatedString
	//
	// Type: []string, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: string, ElemKind: string
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedString) {
			s := make([]any, len(t.RepeatedString))
			for i, v := range t.RepeatedString {
				s[i] = v
			}
			m["repeatedstring"] = s
		}
	}

	// # t.RepeatedUint64
	//
	// Type: []uint64, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint64, ElemKind: uint64
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedUint64) {
			s := make([]any, len(t.RepeatedUint64))
			for i, v := range t.RepeatedUint64 {
				s[i] = v
			}
			m["repeateduint64"] = s
		}
	}

	// # t.String
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.String) {
			m["string"] = t.String
		}
	}

	// # t.StringConst
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["stringConst"] = "foo"
	}

	// # t.Uint64
	//
	// Type: uint64, Kind: uint64
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Uint64) {
			m["uint64"] = t.Uint64
		}
	}

	return m
}

func (t *codegenFixture) FromDocumentMap(m DocumentMap) {
	*t = codegenFixture{}

	// # t.Bool
	//
	// Type: bool, Kind: bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["bool"].(bool); ok {
			t.Bool = v
		}
	}

	// # t.Bytes
	//
	// Type: []uint8, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["bytes"].([]byte); ok {
			t.Bytes = v
		}
	}

	// # t.Int64
	//
	// Type: int64, Kind: int64
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["int64"].(int64); ok {
			t.Int64 = v
		}
	}

	// # t.MapPtr
	//
	// Type: nimona.codegenFixture, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: true
	{
		if v, ok := m["mapPtr"].(DocumentMap); ok {
			e := codegenFixture{}
			e.FromDocumentMap(v)
			t.MapPtr = &e
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

	// # t.RepeatedBool
	//
	// Type: []bool, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: bool, ElemKind: bool
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["repeatedbool"].([]any); ok {
			s := make([]bool, len(v))
			for i, vi := range v {
				s[i] = vi.(bool)
			}
			t.RepeatedBool = s
		}
	}

	// # t.RepeatedBytes
	//
	// Type: [][]uint8, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: []uint8, ElemKind: slice
	// IsElemSlice: true, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["repeatedbytes"].([]any); ok {
			s := make([][]byte, len(v))
			for i, vi := range v {
				s[i] = vi.([]byte)
			}
			t.RepeatedBytes = s
		}
	}

	// # t.RepeatedInt64
	//
	// Type: []int64, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: int64, ElemKind: int64
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["repeatedint64"].([]any); ok {
			s := make([]int64, len(v))
			for i, vi := range v {
				s[i] = vi.(int64)
			}
			t.RepeatedInt64 = s
		}
	}

	// # t.RepeatedMap
	//
	// Type: []nimona.codegenFixture, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.codegenFixture, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []codegenFixture{}
		if vs, ok := m["repeatedmap"].([]any); ok {
			for _, vi := range vs {
				v, ok := vi.(DocumentMap)
				if ok {
					e := codegenFixture{}
					e.FromDocumentMap(v)
					sm = append(sm, e)
				}
			}
		}
		if len(sm) > 0 {
			t.RepeatedMap = sm
		}
	}

	// # t.RepeatedMapPtr
	//
	// Type: []*nimona.codegenFixture, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.codegenFixture, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: true
	{
		sm := []*codegenFixture{} // codegenFixture
		if vs, ok := m["repeatedmapPtr"].([]any); ok {
			for _, vi := range vs {
				v, ok := vi.(DocumentMap)
				if ok {
					e := &codegenFixture{}
					e.FromDocumentMap(v)
					sm = append(sm, e)
				}
			}
		}
		if len(sm) > 0 {
			t.RepeatedMapPtr = sm
		}
	}

	// # t.RepeatedString
	//
	// Type: []string, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: string, ElemKind: string
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["repeatedstring"].([]any); ok {
			s := make([]string, len(v))
			for i, vi := range v {
				s[i] = vi.(string)
			}
			t.RepeatedString = s
		}
	}

	// # t.RepeatedUint64
	//
	// Type: []uint64, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint64, ElemKind: uint64
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, ok := m["repeateduint64"].([]any); ok {
			s := make([]uint64, len(v))
			for i, vi := range v {
				s[i] = vi.(uint64)
			}
			t.RepeatedUint64 = s
		}
	}

	// # t.String
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["string"].(string); ok {
			t.String = v
		}
	}

	// # t.Uint64
	//
	// Type: uint64, Kind: uint64
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["uint64"].(uint64); ok {
			t.Uint64 = v
		}
	}

}
func (t *codegenFixtureWithType) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "foobar"
	}

	// # t.String
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.String) {
			m["string"] = t.String
		}
	}

	return m
}

func (t *codegenFixtureWithType) FromDocumentMap(m DocumentMap) {
	*t = codegenFixtureWithType{}

	// # t.String
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["string"].(string); ok {
			t.String = v
		}
	}

}
