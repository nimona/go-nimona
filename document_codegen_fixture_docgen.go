// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"

	"nimona.io/internal/tilde"
)

var _ = zero.IsZeroVal
var _ = tilde.NewScanner

func (t *codegenFixture) Document() *Document {
	return NewDocument(t.Map())
}

func (t *codegenFixture) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("foo"))
	}

	// # t.Bool
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Bool) {
			m.Set("bool", tilde.Bool(t.Bool))
		}
	}

	// # t.Bytes
	//
	// Type: []uint8, Kind: slice, TildeKind: Bytes
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.Bytes) {
			m.Set("bytes", tilde.Bytes(t.Bytes))
		}
	}

	// # t.Int64
	//
	// Type: int64, Kind: int64, TildeKind: Int64
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Int64) {
			m.Set("int64", tilde.Int64(t.Int64))
		}
	}

	// # t.MapPtr
	//
	// Type: nimona.codegenFixture, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: true
	{
		if !zero.IsZeroVal(t.MapPtr) {
			m.Set("mapPtr", t.MapPtr.Map())
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m.Set("$metadata", t.Metadata.Map())
		}
	}

	// # t.RepeatedBool
	//
	// Type: []bool, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: bool, ElemKind: bool
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedBool) {
			s := make(tilde.List, len(t.RepeatedBool))
			for i, v := range t.RepeatedBool {
				s[i] = tilde.Bool(v)
			}
			m.Set("repeatedbool", s)
		}
	}

	// # t.RepeatedBytes
	//
	// Type: [][]uint8, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: []uint8, ElemKind: slice
	// IsElemSlice: true, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedBytes) {
			s := make(tilde.List, len(t.RepeatedBytes))
			for i, v := range t.RepeatedBytes {
				s[i] = tilde.Bytes(v)
			}
			m.Set("repeatedbytes", s)
		}
	}

	// # t.RepeatedInt64
	//
	// Type: []int64, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: int64, ElemKind: int64
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedInt64) {
			s := make(tilde.List, len(t.RepeatedInt64))
			for i, v := range t.RepeatedInt64 {
				s[i] = tilde.Int64(v)
			}
			m.Set("repeatedint64", s)
		}
	}

	// # t.RepeatedMap
	//
	// Type: []nimona.codegenFixture, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.codegenFixture, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedMap) {
			sm := tilde.List{}
			for _, v := range t.RepeatedMap {
				if !zero.IsZeroVal(t.RepeatedMap) {
					sm = append(sm, v.Map())
				}
			}
			m.Set("repeatedmap", sm)
		}
	}

	// # t.RepeatedMapPtr
	//
	// Type: []*nimona.codegenFixture, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.codegenFixture, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: true
	{
		if !zero.IsZeroVal(t.RepeatedMapPtr) {
			sm := tilde.List{}
			for _, v := range t.RepeatedMapPtr {
				if !zero.IsZeroVal(t.RepeatedMapPtr) {
					sm = append(sm, v.Map())
				}
			}
			m.Set("repeatedmapPtr", sm)
		}
	}

	// # t.RepeatedString
	//
	// Type: []string, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: string, ElemKind: string
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedString) {
			s := make(tilde.List, len(t.RepeatedString))
			for i, v := range t.RepeatedString {
				s[i] = tilde.String(v)
			}
			m.Set("repeatedstring", s)
		}
	}

	// # t.RepeatedUint64
	//
	// Type: []uint64, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint64, ElemKind: uint64
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if !zero.IsZeroVal(t.RepeatedUint64) {
			s := make(tilde.List, len(t.RepeatedUint64))
			for i, v := range t.RepeatedUint64 {
				s[i] = tilde.Uint64(v)
			}
			m.Set("repeateduint64", s)
		}
	}

	// # t.String
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.String) {
			m.Set("string", tilde.String(t.String))
		}
	}

	// # t.StringConst
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("stringConst", tilde.String("foo"))
	}

	// # t.Uint64
	//
	// Type: uint64, Kind: uint64, TildeKind: Uint64
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.Uint64) {
			m.Set("uint64", tilde.Uint64(t.Uint64))
		}
	}

	return m
}

func (t *codegenFixture) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *codegenFixture) FromMap(d tilde.Map) error {
	*t = codegenFixture{}

	// # t.Bool
	//
	// Type: bool, Kind: bool, TildeKind: Bool
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("bool"); err == nil {
			if v, ok := v.(tilde.Bool); ok {
				t.Bool = bool(v)
			}
		}
	}

	// # t.Bytes
	//
	// Type: []uint8, Kind: slice, TildeKind: Bytes
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint8, ElemKind: uint8, ElemTildeKind: InvalidValueKind0
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get("bytes"); err == nil {
			if v, ok := v.(tilde.Bytes); ok {
				t.Bytes = []byte(v)
			}
		}
	}

	// # t.Int64
	//
	// Type: int64, Kind: int64, TildeKind: Int64
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("int64"); err == nil {
			if v, ok := v.(tilde.Int64); ok {
				t.Int64 = int64(v)
			}
		}
	}

	// # t.MapPtr
	//
	// Type: nimona.codegenFixture, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: true
	{
		if v, err := d.Get("mapPtr"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := codegenFixture{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.MapPtr = &e
			}
		}
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct, TildeKind: Map
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, err := d.Get("$metadata"); err == nil {
			if v, ok := v.(tilde.Map); ok {
				e := Metadata{}
				d := NewDocument(v)
				e.FromDocument(d)
				t.Metadata = e
			}
		}
	}

	// # t.RepeatedBool
	//
	// Type: []bool, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: bool, ElemKind: bool, ElemTildeKind: Bool
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get("repeatedbool"); err == nil {
			if v, ok := v.(tilde.List); ok {
				s := make([]bool, len(v))
				for i, vi := range v {
					if vi, ok := vi.(tilde.Bool); ok {
						s[i] = bool(vi)
					}
				}
				t.RepeatedBool = s
			}
		}
	}

	// # t.RepeatedBytes
	//
	// Type: [][]uint8, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: []uint8, ElemKind: slice, ElemTildeKind: Bytes
	// IsElemSlice: true, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get("repeatedbytes"); err == nil {
			if v, ok := v.(tilde.List); ok {
				s := make([][]uint8, len(v))
				for i, vi := range v {
					if vi, ok := vi.(tilde.Bytes); ok {
						s[i] = []uint8(vi)
					}
				}
				t.RepeatedBytes = s
			}
		}
	}

	// # t.RepeatedInt64
	//
	// Type: []int64, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: int64, ElemKind: int64, ElemTildeKind: Int64
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get("repeatedint64"); err == nil {
			if v, ok := v.(tilde.List); ok {
				s := make([]int64, len(v))
				for i, vi := range v {
					if vi, ok := vi.(tilde.Int64); ok {
						s[i] = int64(vi)
					}
				}
				t.RepeatedInt64 = s
			}
		}
	}

	// # t.RepeatedMap
	//
	// Type: []nimona.codegenFixture, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.codegenFixture, ElemKind: struct, ElemTildeKind: Map
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []codegenFixture{}
		if vs, err := d.Get("repeatedmap"); err == nil {
			if vs, ok := vs.(tilde.List); ok {
				for _, vi := range vs {
					if v, ok := vi.(tilde.Map); ok {
						e := codegenFixture{}
						d := NewDocument(v)
						e.FromDocument(d)
						sm = append(sm, e)
					}
				}
			}
		}
		if len(sm) > 0 {
			t.RepeatedMap = sm
		}
	}

	// # t.RepeatedMapPtr
	//
	// Type: []*nimona.codegenFixture, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.codegenFixture, ElemKind: struct, ElemTildeKind: Map
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: true
	{
		sm := []*codegenFixture{} // codegenFixture
		if vs, err := d.Get("repeatedmapPtr"); err == nil {
			if vs, ok := vs.(tilde.List); ok {
				for _, vi := range vs {
					if v, ok := vi.(tilde.Map); ok {
						e := &codegenFixture{}
						d := NewDocument(v)
						e.FromDocument(d)
						sm = append(sm, e)
					}
				}
			}
		}
		if len(sm) > 0 {
			t.RepeatedMapPtr = sm
		}
	}

	// # t.RepeatedString
	//
	// Type: []string, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: string, ElemKind: string, ElemTildeKind: String
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get("repeatedstring"); err == nil {
			if v, ok := v.(tilde.List); ok {
				s := make([]string, len(v))
				for i, vi := range v {
					if vi, ok := vi.(tilde.String); ok {
						s[i] = string(vi)
					}
				}
				t.RepeatedString = s
			}
		}
	}

	// # t.RepeatedUint64
	//
	// Type: []uint64, Kind: slice, TildeKind: List
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: uint64, ElemKind: uint64, ElemTildeKind: Uint64
	// IsElemSlice: false, IsElemStruct: false, IsElemPointer: false
	{
		if v, err := d.Get("repeateduint64"); err == nil {
			if v, ok := v.(tilde.List); ok {
				s := make([]uint64, len(v))
				for i, vi := range v {
					if vi, ok := vi.(tilde.Uint64); ok {
						s[i] = uint64(vi)
					}
				}
				t.RepeatedUint64 = s
			}
		}
	}

	// # t.String
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("string"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.String = string(v)
			}
		}
	}

	// # t.Uint64
	//
	// Type: uint64, Kind: uint64, TildeKind: Uint64
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("uint64"); err == nil {
			if v, ok := v.(tilde.Uint64); ok {
				t.Uint64 = uint64(v)
			}
		}
	}

	return nil
}
func (t *codegenFixtureWithType) Document() *Document {
	return NewDocument(t.Map())
}

func (t *codegenFixtureWithType) Map() tilde.Map {
	m := tilde.Map{}

	// # t.$type
	//
	// Type: string, Kind: string, TildeKind: InvalidValueKind0
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m.Set("$type", tilde.String("foobar"))
	}

	// # t.String
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if !zero.IsZeroVal(t.String) {
			m.Set("string", tilde.String(t.String))
		}
	}

	return m
}

func (t *codegenFixtureWithType) FromDocument(d *Document) error {
	return t.FromMap(d.Map())
}

func (t *codegenFixtureWithType) FromMap(d tilde.Map) error {
	*t = codegenFixtureWithType{}

	// # t.String
	//
	// Type: string, Kind: string, TildeKind: String
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, err := d.Get("string"); err == nil {
			if v, ok := v.(tilde.String); ok {
				t.String = string(v)
			}
		}
	}

	return nil
}
