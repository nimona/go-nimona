// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package handshake

import (
	"nimona.io/pkg/immutable"
	object "nimona.io/pkg/object"
)

type (
	Syn struct {
		Header object.Header
		Nonce  string
	}
	SynAck struct {
		Header object.Header
		Nonce  string
	}
	Ack struct {
		Header object.Header
		Nonce  string
	}
)

func (e Syn) GetType() string {
	return "nimona.io/net/handshake.Syn"
}

func (e Syn) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e Syn) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Nonce != "" {
		d["nonce:s"] = e.Nonce
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/net/handshake.Syn")
	return o
}

func (e *Syn) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("nonce:s"); v != nil {
		e.Nonce = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e SynAck) GetType() string {
	return "nimona.io/net/handshake.SynAck"
}

func (e SynAck) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e SynAck) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Nonce != "" {
		d["nonce:s"] = e.Nonce
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/net/handshake.SynAck")
	return o
}

func (e *SynAck) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("nonce:s"); v != nil {
		e.Nonce = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e Ack) GetType() string {
	return "nimona.io/net/handshake.Ack"
}

func (e Ack) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{
			&object.SchemaProperty{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e Ack) ToObject() object.Object {
	d := map[string]interface{}{}
	if e.Nonce != "" {
		d["nonce:s"] = e.Nonce
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := object.Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/net/handshake.Ack")
	return o
}

func (e *Ack) FromObject(o object.Object) error {
	e.Header = o.Header
	if v := o.Data.Value("nonce:s"); v != nil {
		e.Nonce = string(v.PrimitiveHinted().(string))
	}
	return nil
}
