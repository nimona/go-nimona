// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package handshake

import (
	json "encoding/json"

	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
	schema "nimona.io/pkg/schema"
)

type (
	Syn struct {
		Nonce     string             `json:"nonce:s,omitempty"`
		Signature *crypto.Signature  `json:"_signature:o,omitempty"`
		Owners    []crypto.PublicKey `json:"@owners:as,omitempty"`
	}
	SynAck struct {
		Nonce     string             `json:"nonce:s,omitempty"`
		Signature *crypto.Signature  `json:"_signature:o,omitempty"`
		Owners    []crypto.PublicKey `json:"@owners:as,omitempty"`
	}
	Ack struct {
		Nonce     string             `json:"nonce:s,omitempty"`
		Signature *crypto.Signature  `json:"_signature:o,omitempty"`
		Owners    []crypto.PublicKey `json:"@owners:as,omitempty"`
	}
)

func (e Syn) GetType() string {
	return "nimona.io/net/handshake.Syn"
}

func (e Syn) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "_signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@owners",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e Syn) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/net/handshake.Syn"
	if e.Nonce != "" {
		m["nonce:s"] = e.Nonce
	}
	if e.Signature != nil {
		m["_signature:o"] = e.Signature.ToObject().ToMap()
	}
	if len(e.Owners) > 0 {
		m["@owners:as"] = e.Owners
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Syn) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e SynAck) GetType() string {
	return "nimona.io/net/handshake.SynAck"
}

func (e SynAck) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "_signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@owners",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e SynAck) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/net/handshake.SynAck"
	if e.Nonce != "" {
		m["nonce:s"] = e.Nonce
	}
	if e.Signature != nil {
		m["_signature:o"] = e.Signature.ToObject().ToMap()
	}
	if len(e.Owners) > 0 {
		m["@owners:as"] = e.Owners
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *SynAck) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e Ack) GetType() string {
	return "nimona.io/net/handshake.Ack"
}

func (e Ack) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "_signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@owners",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e Ack) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/net/handshake.Ack"
	if e.Nonce != "" {
		m["nonce:s"] = e.Nonce
	}
	if e.Signature != nil {
		m["_signature:o"] = e.Signature.ToObject().ToMap()
	}
	if len(e.Owners) > 0 {
		m["@owners:as"] = e.Owners
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Ack) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
