// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package peer

import (
	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
)

type (
	ConnectionInfo struct {
		Metadata  object.Metadata   `nimona:"metadata:m,omitempty"`
		PublicKey crypto.PublicKey  `nimona:"publicKey:s,omitempty"`
		Addresses []string          `nimona:"addresses:as,omitempty"`
		Relays    []*ConnectionInfo `nimona:"relays:ao,omitempty"`
	}
)

func (e *ConnectionInfo) Type() string {
	return "nimona.io/peer.ConnectionInfo"
}

func (e ConnectionInfo) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/peer.ConnectionInfo",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["publicKey:s"] = e.PublicKey
	if len(e.Addresses) > 0 {
		// rv := make([]string, len(e.Addresses))
		// for i, v := range e.Addresses {
		// 	rv[i] = v
		// }
		r.Data["addresses:as"] = e.Addresses
	}
	if len(e.Relays) > 0 {
		rv := make([]*object.Object, len(e.Relays))
		for i, v := range e.Relays {
			rv[i] = v.ToObject()
		}
		r.Data["relays:ao"] = rv
	}
	return r
}

func (e *ConnectionInfo) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}
