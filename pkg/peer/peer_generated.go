// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package peer

import (
	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
)

type (
	ConnectionInfo struct {
		Metadata      object.Metadata `nimona:"metadata:m,omitempty"`
		Version       int64
		PublicKey     crypto.PublicKey
		Addresses     []string
		Relays        []*ConnectionInfo
		ObjectFormats []string
	}
)

func (e *ConnectionInfo) Type() string {
	return "nimona.io/peer.ConnectionInfo"
}

func (e ConnectionInfo) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/peer.ConnectionInfo",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["version"] = object.Int(e.Version)
	r.Data["version"] = object.Int(e.Version)
	// else if $member.IsPrimitive
	r.Data["publicKey"] = object.String(e.PublicKey)
	// if $member.IsRepeated
	if len(e.Addresses) > 0 {
		// else
		// r.Data["addresses"] = object.ToStringArray(e.Addresses)
		rv := make(object.StringArray, len(e.Addresses))
		for i, iv := range e.Addresses {
			rv[i] = object.String(iv)
		}
		r.Data["addresses"] = rv
	}
	// if $member.IsRepeated
	if len(e.Relays) > 0 {
		// if $member.IsObject
		rv := make(object.ObjectArray, len(e.Relays))
		for i, v := range e.Relays {
			rv[i] = v.ToObject()
		}
		r.Data["relays"] = rv
	}
	// if $member.IsRepeated
	if len(e.ObjectFormats) > 0 {
		// else
		// r.Data["objectFormats"] = object.ToStringArray(e.ObjectFormats)
		rv := make(object.StringArray, len(e.ObjectFormats))
		for i, iv := range e.ObjectFormats {
			rv[i] = object.String(iv)
		}
		r.Data["objectFormats"] = rv
	}
	return r
}

func (e *ConnectionInfo) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["version"]; ok {
		if t, ok := v.(object.Int); ok {
			e.Version = int64(t)
		}
	}
	if v, ok := o.Data["publicKey"]; ok {
		if t, ok := v.(object.String); ok {
			e.PublicKey = crypto.PublicKey(t)
		}
	}
	if v, ok := o.Data["addresses"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.Addresses = rv
		}
	}
	if v, ok := o.Data["relays"]; ok {
		if t, ok := v.(object.MapArray); ok {
			e.Relays = make([]*ConnectionInfo, len(t))
			for i, iv := range t {
				es := &ConnectionInfo{}
				eo := object.FromMap(iv)
				es.FromObject(eo)
				e.Relays[i] = es
			}
		} else if t, ok := v.(object.ObjectArray); ok {
			e.Relays = make([]*ConnectionInfo, len(t))
			for i, iv := range t {
				es := &ConnectionInfo{}
				es.FromObject(iv)
				e.Relays[i] = es
			}
		}
	}
	if v, ok := o.Data["objectFormats"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.ObjectFormats = rv
		}
	}
	return nil
}
