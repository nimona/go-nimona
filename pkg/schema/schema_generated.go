// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package schema

import (
	json "encoding/json"

	object "nimona.io/pkg/object"
)

type (
	Property struct {
		Name       string      `json:"name:s,omitempty"`
		Type       string      `json:"type:s,omitempty"`
		Hint       string      `json:"hint:s,omitempty"`
		IsRepeated bool        `json:"isRepeated:b,omitempty"`
		IsOptional bool        `json:"isOptional:b,omitempty"`
		Properties []*Property `json:"properties:ao,omitempty"`
	}
	Link struct {
		Type       string `json:"type:s,omitempty"`
		Direction  string `json:"direction:s,omitempty"`
		IsOptional bool   `json:"isOptional:b,omitempty"`
	}
	Object struct {
		Properties []*Property `json:"properties:ao,omitempty"`
		Links      []*Link     `json:"links:ao,omitempty"`
	}
)

func (e Property) GetType() string {
	return "nimona.io/schema.Property"
}

func (e Property) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/schema.Property"
	if e.Name != "" {
		m["name:s"] = e.Name
	}
	if e.Type != "" {
		m["type:s"] = e.Type
	}
	if e.Hint != "" {
		m["hint:s"] = e.Hint
	}
	m["isRepeated:b"] = e.IsRepeated
	m["isOptional:b"] = e.IsOptional
	if len(e.Properties) > 0 {
		m["properties:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Properties))
			for i, v := range e.Properties {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}

	return object.Object(m)
}

func (e *Property) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e Link) GetType() string {
	return "nimona.io/schema.Link"
}

func (e Link) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/schema.Link"
	if e.Type != "" {
		m["type:s"] = e.Type
	}
	if e.Direction != "" {
		m["direction:s"] = e.Direction
	}
	m["isOptional:b"] = e.IsOptional

	return object.Object(m)
}

func (e *Link) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e Object) GetType() string {
	return "nimona.io/schema.Object"
}

func (e Object) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/schema.Object"
	if len(e.Properties) > 0 {
		m["properties:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Properties))
			for i, v := range e.Properties {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}
	if len(e.Links) > 0 {
		m["links:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Links))
			for i, v := range e.Links {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}

	return object.Object(m)
}

func (e *Object) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
