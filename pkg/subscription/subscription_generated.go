// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package subscription

import (
	"errors"

	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
)

type (
	Subscription struct {
		raw        object.Object
		Stream     object.Hash
		Parents    []object.Hash
		Owners     []crypto.PublicKey
		Policy     object.Policy
		Signatures []object.Signature
		Subjects   []crypto.PublicKey
		Types      []string
		Streams    []object.Hash
		Expiry     string
	}
	SubscriptionStreamRoot struct {
		raw        object.Object
		Stream     object.Hash
		Parents    []object.Hash
		Owners     []crypto.PublicKey
		Policy     object.Policy
		Signatures []object.Signature
		Name       string
	}
	SubscriptionAdded struct {
		raw          object.Object
		Stream       object.Hash
		Parents      []object.Hash
		Owners       []crypto.PublicKey
		Policy       object.Policy
		Signatures   []object.Signature
		Subscription object.Hash
	}
	SubscriptionRemoved struct {
		raw          object.Object
		Stream       object.Hash
		Parents      []object.Hash
		Owners       []crypto.PublicKey
		Policy       object.Policy
		Signatures   []object.Signature
		Subscription object.Hash
	}
)

func (e Subscription) GetType() string {
	return "nimona.io/subscription.Subscription"
}

func (e Subscription) IsStreamRoot() bool {
	return false
}

func (e Subscription) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "subjects",
			Type:       "nimona.io/crypto.PublicKey",
			Hint:       "s",
			IsRepeated: true,
			IsOptional: false,
		}, {
			Name:       "types",
			Type:       "string",
			Hint:       "s",
			IsRepeated: true,
			IsOptional: false,
		}, {
			Name:       "streams",
			Type:       "nimona.io/object.Hash",
			Hint:       "s",
			IsRepeated: true,
			IsOptional: false,
		}, {
			Name:       "expiry",
			Type:       "string",
			Hint:       "s",
			IsRepeated: false,
			IsOptional: false,
		}},
	}
}

func (e Subscription) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("nimona.io/subscription.Subscription")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if len(e.Subjects) > 0 {
		v := object.List{}
		for _, iv := range e.Subjects {
			v = v.Append(object.String(iv))
		}
		o = o.Set("subjects:as", v)
	}
	if len(e.Types) > 0 {
		v := object.List{}
		for _, iv := range e.Types {
			v = v.Append(object.String(iv))
		}
		o = o.Set("types:as", v)
	}
	if len(e.Streams) > 0 {
		v := object.List{}
		for _, iv := range e.Streams {
			v = v.Append(object.String(iv))
		}
		o = o.Set("streams:as", v)
	}
	if e.Expiry != "" {
		o = o.Set("expiry:s", e.Expiry)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *Subscription) FromObject(o object.Object) error {
	data, ok := o.Raw().Value("data:m").(object.Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("subjects:as"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]string)
		e.Subjects = make([]crypto.PublicKey, len(m))
		for i, iv := range m {
			e.Subjects[i] = crypto.PublicKey(iv)
		}
	}
	if v := data.Value("types:as"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]string)
		e.Types = make([]string, len(m))
		for i, iv := range m {
			e.Types[i] = string(iv)
		}
	}
	if v := data.Value("streams:as"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]string)
		e.Streams = make([]object.Hash, len(m))
		for i, iv := range m {
			e.Streams[i] = object.Hash(iv)
		}
	}
	if v := data.Value("expiry:s"); v != nil {
		e.Expiry = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e SubscriptionStreamRoot) GetType() string {
	return "stream:nimona.io/subscription"
}

func (e SubscriptionStreamRoot) IsStreamRoot() bool {
	return true
}

func (e SubscriptionStreamRoot) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "name",
			Type:       "string",
			Hint:       "s",
			IsRepeated: false,
			IsOptional: false,
		}},
	}
}

func (e SubscriptionStreamRoot) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("stream:nimona.io/subscription")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.Name != "" {
		o = o.Set("name:s", e.Name)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *SubscriptionStreamRoot) FromObject(o object.Object) error {
	data, ok := o.Raw().Value("data:m").(object.Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("name:s"); v != nil {
		e.Name = string(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e SubscriptionAdded) GetType() string {
	return "event:nimona.io/subscription.SubscriptionAdded"
}

func (e SubscriptionAdded) IsStreamRoot() bool {
	return false
}

func (e SubscriptionAdded) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "subscription",
			Type:       "nimona.io/object.Hash",
			Hint:       "s",
			IsRepeated: false,
			IsOptional: false,
		}},
	}
}

func (e SubscriptionAdded) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("event:nimona.io/subscription.SubscriptionAdded")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.Subscription != "" {
		o = o.Set("subscription:s", e.Subscription)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *SubscriptionAdded) FromObject(o object.Object) error {
	data, ok := o.Raw().Value("data:m").(object.Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("subscription:s"); v != nil {
		e.Subscription = object.Hash(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e SubscriptionRemoved) GetType() string {
	return "event:nimona.io/subscription.SubscriptionRemoved"
}

func (e SubscriptionRemoved) IsStreamRoot() bool {
	return false
}

func (e SubscriptionRemoved) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "subscription",
			Type:       "nimona.io/object.Hash",
			Hint:       "s",
			IsRepeated: false,
			IsOptional: false,
		}},
	}
}

func (e SubscriptionRemoved) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("event:nimona.io/subscription.SubscriptionRemoved")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.Subscription != "" {
		o = o.Set("subscription:s", e.Subscription)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *SubscriptionRemoved) FromObject(o object.Object) error {
	data, ok := o.Raw().Value("data:m").(object.Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("subscription:s"); v != nil {
		e.Subscription = object.Hash(v.PrimitiveHinted().(string))
	}
	return nil
}
