// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package stream

import (
	object "nimona.io/pkg/object"
)

type (
	Policy struct {
		Metadata   object.Metadata `nimona:"metadata:m,omitempty"`
		Subjects   []string        `nimona:"subjects:as,omitempty"`
		Resources  []string        `nimona:"resources:as,omitempty"`
		Conditions []string        `nimona:"conditions:as,omitempty"`
		Action     string          `nimona:"action:s,omitempty"`
	}
	Request struct {
		Metadata  object.Metadata `nimona:"metadata:m,omitempty"`
		RequestID string          `nimona:"requestID:s,omitempty"`
		RootHash  object.Hash     `nimona:"rootHash:r,omitempty"`
	}
	Response struct {
		Metadata  object.Metadata `nimona:"metadata:m,omitempty"`
		RequestID string          `nimona:"requestID:s,omitempty"`
		RootHash  object.Hash     `nimona:"rootHash:r,omitempty"`
		Leaves    []object.Hash   `nimona:"leaves:ar,omitempty"`
	}
	Announcement struct {
		Metadata     object.Metadata `nimona:"metadata:m,omitempty"`
		StreamHash   object.Hash     `nimona:"streamHash:r,omitempty"`
		ObjectHashes []object.Hash   `nimona:"objectHashes:ar,omitempty"`
	}
	Subscription struct {
		Metadata   object.Metadata `nimona:"metadata:m,omitempty"`
		RootHashes []object.Hash   `nimona:"rootHashes:ar,omitempty"`
		Expiry     string          `nimona:"expiry:s,omitempty"`
	}
)

func (e *Policy) Type() string {
	return "nimona.io/stream.Policy"
}

func (e Policy) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Policy",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	if len(e.Subjects) > 0 {
		r.Data["subjects:as"] = e.Subjects
	}
	if len(e.Resources) > 0 {
		r.Data["resources:as"] = e.Resources
	}
	if len(e.Conditions) > 0 {
		r.Data["conditions:as"] = e.Conditions
	}
	r.Data["action:s"] = e.Action
	return r
}

func (e Policy) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	if len(e.Subjects) > 0 {
		d["subjects:as"] = e.Subjects
	}
	if len(e.Resources) > 0 {
		d["resources:as"] = e.Resources
	}
	if len(e.Conditions) > 0 {
		d["conditions:as"] = e.Conditions
	}
	d["action:s"] = e.Action
	r := map[string]interface{}{
		"type:s":     "nimona.io/stream.Policy",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *Policy) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *Request) Type() string {
	return "nimona.io/stream.Request"
}

func (e Request) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Request",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["requestID:s"] = e.RequestID
	r.Data["rootHash:r"] = e.RootHash
	return r
}

func (e Request) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	d["requestID:s"] = e.RequestID
	d["rootHash:r"] = e.RootHash
	r := map[string]interface{}{
		"type:s":     "nimona.io/stream.Request",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *Request) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *Response) Type() string {
	return "nimona.io/stream.Response"
}

func (e Response) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Response",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["requestID:s"] = e.RequestID
	r.Data["rootHash:r"] = e.RootHash
	if len(e.Leaves) > 0 {
		r.Data["leaves:ar"] = e.Leaves
	}
	return r
}

func (e Response) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	d["requestID:s"] = e.RequestID
	d["rootHash:r"] = e.RootHash
	if len(e.Leaves) > 0 {
		d["leaves:ar"] = e.Leaves
	}
	r := map[string]interface{}{
		"type:s":     "nimona.io/stream.Response",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *Response) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *Announcement) Type() string {
	return "nimona.io/stream.Announcement"
}

func (e Announcement) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Announcement",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	r.Data["streamHash:r"] = e.StreamHash
	if len(e.ObjectHashes) > 0 {
		r.Data["objectHashes:ar"] = e.ObjectHashes
	}
	return r
}

func (e Announcement) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	d["streamHash:r"] = e.StreamHash
	if len(e.ObjectHashes) > 0 {
		d["objectHashes:ar"] = e.ObjectHashes
	}
	r := map[string]interface{}{
		"type:s":     "nimona.io/stream.Announcement",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *Announcement) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}

func (e *Subscription) Type() string {
	return "nimona.io/stream.Subscription"
}

func (e Subscription) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Subscription",
		Metadata: e.Metadata,
		Data:     map[string]interface{}{},
	}
	if len(e.RootHashes) > 0 {
		r.Data["rootHashes:ar"] = e.RootHashes
	}
	r.Data["expiry:s"] = e.Expiry
	return r
}

func (e Subscription) ToObjectMap() map[string]interface{} {
	d := map[string]interface{}{}
	if len(e.RootHashes) > 0 {
		d["rootHashes:ar"] = e.RootHashes
	}
	d["expiry:s"] = e.Expiry
	r := map[string]interface{}{
		"type:s":     "nimona.io/stream.Subscription",
		"metadata:m": object.MetadataToMap(&e.Metadata),
		"data:m":     d,
	}
	return r
}

func (e *Subscription) FromObject(o *object.Object) error {
	return object.Decode(o, e)
}
