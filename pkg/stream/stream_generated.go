// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package stream

import (
	json "encoding/json"

	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
	schema "nimona.io/pkg/schema"
)

type (
	Policy struct {
		Subjects   []string `json:"subjects:as,omitempty"`
		Resources  []string `json:"resources:as,omitempty"`
		Conditions []string `json:"conditions:as,omitempty"`
		Action     string   `json:"action:s,omitempty"`
	}
	StreamRequest struct {
		Nonce     string            `json:"nonce:s,omitempty"`
		Stream    object.Hash       `json:"stream:s,omitempty"`
		Signature *crypto.Signature `json:"@signature:o,omitempty"`
		Identity  crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
	StreamResponse struct {
		Nonce     string            `json:"nonce:s,omitempty"`
		Stream    object.Hash       `json:"stream:s,omitempty"`
		Children  []object.Hash     `json:"children:as,omitempty"`
		Signature *crypto.Signature `json:"@signature:o,omitempty"`
		Identity  crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
	ObjectRequest struct {
		Nonce     string            `json:"nonce:s,omitempty"`
		Hash      object.Hash       `json:"hash:s,omitempty"`
		Signature *crypto.Signature `json:"@signature:o,omitempty"`
		Identity  crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
	ObjectResponse struct {
		Nonce     string            `json:"nonce:s,omitempty"`
		Hash      object.Hash       `json:"hash:s,omitempty"`
		Signature *crypto.Signature `json:"@signature:o,omitempty"`
		Identity  crypto.PublicKey  `json:"@identity:s,omitempty"`
	}
)

func (e Policy) GetType() string {
	return "nimona.io/stream.Policy"
}

func (e Policy) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "subjects",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "resources",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "conditions",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "action",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e Policy) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/stream.Policy"
	if len(e.Subjects) > 0 {
		m["subjects:as"] = e.Subjects
	}
	if len(e.Resources) > 0 {
		m["resources:as"] = e.Resources
	}
	if len(e.Conditions) > 0 {
		m["conditions:as"] = e.Conditions
	}
	if e.Action != "" {
		m["action:s"] = e.Action
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Policy) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e StreamRequest) GetType() string {
	return "nimona.io/stream.StreamRequest"
}

func (e StreamRequest) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "stream",
				Type:       "nimona.io/object.Hash",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e StreamRequest) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/stream.StreamRequest"
	if e.Nonce != "" {
		m["nonce:s"] = e.Nonce
	}
	if e.Stream != "" {
		m["stream:s"] = e.Stream
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *StreamRequest) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e StreamResponse) GetType() string {
	return "nimona.io/stream.StreamResponse"
}

func (e StreamResponse) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "stream",
				Type:       "nimona.io/object.Hash",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "children",
				Type:       "nimona.io/object.Hash",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e StreamResponse) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/stream.StreamResponse"
	if e.Nonce != "" {
		m["nonce:s"] = e.Nonce
	}
	if e.Stream != "" {
		m["stream:s"] = e.Stream
	}
	if len(e.Children) > 0 {
		m["children:as"] = e.Children
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *StreamResponse) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e ObjectRequest) GetType() string {
	return "nimona.io/stream.ObjectRequest"
}

func (e ObjectRequest) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "hash",
				Type:       "nimona.io/object.Hash",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e ObjectRequest) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/stream.ObjectRequest"
	if e.Nonce != "" {
		m["nonce:s"] = e.Nonce
	}
	if e.Hash != "" {
		m["hash:s"] = e.Hash
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *ObjectRequest) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e ObjectResponse) GetType() string {
	return "nimona.io/stream.ObjectResponse"
}

func (e ObjectResponse) GetSchema() *schema.Object {
	return &schema.Object{
		Properties: []*schema.Property{
			&schema.Property{
				Name:       "nonce",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "hash",
				Type:       "nimona.io/object.Hash",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@signature",
				Type:       "nimona.io/crypto.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&schema.Property{
				Name:       "@identity",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
		Links: []*schema.Link{},
	}
}

func (e ObjectResponse) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/stream.ObjectResponse"
	if e.Nonce != "" {
		m["nonce:s"] = e.Nonce
	}
	if e.Hash != "" {
		m["hash:s"] = e.Hash
	}
	if e.Signature != nil {
		m["@signature:o"] = e.Signature.ToObject().ToMap()
	}
	if e.Identity != "" {
		m["@identity:s"] = e.Identity
	}

	if schema := e.GetSchema(); schema != nil {
		m["$schema"] = schema.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *ObjectResponse) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
