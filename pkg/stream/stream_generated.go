// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package stream

import (
	object "nimona.io/pkg/object"
)

type (
	Policy struct {
		Metadata   object.Metadata
		Subjects   []string
		Resources  []string
		Conditions []string
		Action     string
	}
	Request struct {
		Metadata  object.Metadata
		RequestID string
		RootCID   object.CID
	}
	Response struct {
		Metadata  object.Metadata
		RequestID string
		RootCID   object.CID
		Leaves    []object.CID
	}
	Announcement struct {
		Metadata   object.Metadata
		StreamCID  object.CID
		ObjectCIDs []object.CID
	}
	Subscription struct {
		Metadata object.Metadata
		RootCIDs []object.CID
		Expiry   string
	}
)

func (e *Policy) Type() string {
	return "nimona.io/stream.Policy"
}

func (e *Policy) MarshalMap() (object.Map, error) {
	return e.ToObject().Map(), nil
}

func (e *Policy) MarshalObject() (*object.Object, error) {
	return e.ToObject(), nil
}

func (e Policy) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Policy",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	if len(e.Subjects) > 0 {
		rv := make(object.StringArray, len(e.Subjects))
		for i, iv := range e.Subjects {
			rv[i] = object.String(iv)
		}
		r.Data["subjects"] = rv
	}
	if len(e.Resources) > 0 {
		rv := make(object.StringArray, len(e.Resources))
		for i, iv := range e.Resources {
			rv[i] = object.String(iv)
		}
		r.Data["resources"] = rv
	}
	if len(e.Conditions) > 0 {
		rv := make(object.StringArray, len(e.Conditions))
		for i, iv := range e.Conditions {
			rv[i] = object.String(iv)
		}
		r.Data["conditions"] = rv
	}
	r.Data["action"] = object.String(e.Action)
	return r
}

func (e *Policy) UnmarshalMap(m object.Map) error {
	return e.FromObject(object.FromMap(m))
}

func (e *Policy) UnmarshalObject(o *object.Object) error {
	return e.FromObject(o)
}

func (e *Policy) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["subjects"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.Subjects = rv
		}
	}
	if v, ok := o.Data["resources"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.Resources = rv
		}
	}
	if v, ok := o.Data["conditions"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.Conditions = rv
		}
	}
	if v, ok := o.Data["action"]; ok {
		if t, ok := v.(object.String); ok {
			e.Action = string(t)
		}
	}
	return nil
}

func (e *Request) Type() string {
	return "nimona.io/stream.Request"
}

func (e *Request) MarshalMap() (object.Map, error) {
	return e.ToObject().Map(), nil
}

func (e *Request) MarshalObject() (*object.Object, error) {
	return e.ToObject(), nil
}

func (e Request) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Request",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	r.Data["requestID"] = object.String(e.RequestID)
	r.Data["rootCID"] = object.String(e.RootCID)
	return r
}

func (e *Request) UnmarshalMap(m object.Map) error {
	return e.FromObject(object.FromMap(m))
}

func (e *Request) UnmarshalObject(o *object.Object) error {
	return e.FromObject(o)
}

func (e *Request) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["requestID"]; ok {
		if t, ok := v.(object.String); ok {
			e.RequestID = string(t)
		}
	}
	if v, ok := o.Data["rootCID"]; ok {
		if t, ok := v.(object.String); ok {
			e.RootCID = object.CID(t)
		}
	}
	return nil
}

func (e *Response) Type() string {
	return "nimona.io/stream.Response"
}

func (e *Response) MarshalMap() (object.Map, error) {
	return e.ToObject().Map(), nil
}

func (e *Response) MarshalObject() (*object.Object, error) {
	return e.ToObject(), nil
}

func (e Response) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Response",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	r.Data["requestID"] = object.String(e.RequestID)
	r.Data["rootCID"] = object.String(e.RootCID)
	if len(e.Leaves) > 0 {
		rv := make(object.StringArray, len(e.Leaves))
		for i, iv := range e.Leaves {
			rv[i] = object.String(iv)
		}
		r.Data["leaves"] = rv
	}
	return r
}

func (e *Response) UnmarshalMap(m object.Map) error {
	return e.FromObject(object.FromMap(m))
}

func (e *Response) UnmarshalObject(o *object.Object) error {
	return e.FromObject(o)
}

func (e *Response) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["requestID"]; ok {
		if t, ok := v.(object.String); ok {
			e.RequestID = string(t)
		}
	}
	if v, ok := o.Data["rootCID"]; ok {
		if t, ok := v.(object.String); ok {
			e.RootCID = object.CID(t)
		}
	}
	if v, ok := o.Data["leaves"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]object.CID, len(t))
			for i, iv := range t {
				rv[i] = object.CID(iv)
			}
			e.Leaves = rv
		}
	}
	return nil
}

func (e *Announcement) Type() string {
	return "nimona.io/stream.Announcement"
}

func (e *Announcement) MarshalMap() (object.Map, error) {
	return e.ToObject().Map(), nil
}

func (e *Announcement) MarshalObject() (*object.Object, error) {
	return e.ToObject(), nil
}

func (e Announcement) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Announcement",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	r.Data["streamCID"] = object.String(e.StreamCID)
	if len(e.ObjectCIDs) > 0 {
		rv := make(object.StringArray, len(e.ObjectCIDs))
		for i, iv := range e.ObjectCIDs {
			rv[i] = object.String(iv)
		}
		r.Data["objectCIDs"] = rv
	}
	return r
}

func (e *Announcement) UnmarshalMap(m object.Map) error {
	return e.FromObject(object.FromMap(m))
}

func (e *Announcement) UnmarshalObject(o *object.Object) error {
	return e.FromObject(o)
}

func (e *Announcement) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["streamCID"]; ok {
		if t, ok := v.(object.String); ok {
			e.StreamCID = object.CID(t)
		}
	}
	if v, ok := o.Data["objectCIDs"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]object.CID, len(t))
			for i, iv := range t {
				rv[i] = object.CID(iv)
			}
			e.ObjectCIDs = rv
		}
	}
	return nil
}

func (e *Subscription) Type() string {
	return "nimona.io/stream.Subscription"
}

func (e *Subscription) MarshalMap() (object.Map, error) {
	return e.ToObject().Map(), nil
}

func (e *Subscription) MarshalObject() (*object.Object, error) {
	return e.ToObject(), nil
}

func (e Subscription) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/stream.Subscription",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	if len(e.RootCIDs) > 0 {
		rv := make(object.StringArray, len(e.RootCIDs))
		for i, iv := range e.RootCIDs {
			rv[i] = object.String(iv)
		}
		r.Data["rootCIDs"] = rv
	}
	r.Data["expiry"] = object.String(e.Expiry)
	return r
}

func (e *Subscription) UnmarshalMap(m object.Map) error {
	return e.FromObject(object.FromMap(m))
}

func (e *Subscription) UnmarshalObject(o *object.Object) error {
	return e.FromObject(o)
}

func (e *Subscription) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["rootCIDs"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]object.CID, len(t))
			for i, iv := range t {
				rv[i] = object.CID(iv)
			}
			e.RootCIDs = rv
		}
	}
	if v, ok := o.Data["expiry"]; ok {
		if t, ok := v.(object.String); ok {
			e.Expiry = string(t)
		}
	}
	return nil
}
