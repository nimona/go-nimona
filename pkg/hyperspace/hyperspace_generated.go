// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package hyperspace

import (
	object "nimona.io/pkg/object"
	peer "nimona.io/pkg/peer"
)

type (
	Announcement struct {
		Metadata         object.Metadata      `nimona:"metadata:m,omitempty"`
		Version          int64                `nimona:"version:i,omitempty"`
		ConnectionInfo   *peer.ConnectionInfo `nimona:"connectionInfo:o,omitempty"`
		PeerVector       []uint64             `nimona:"peerVector:au,omitempty"`
		PeerCapabilities []string             `nimona:"peerCapabilities:as,omitempty"`
	}
	LookupRequest struct {
		Metadata            object.Metadata `nimona:"metadata:m,omitempty"`
		Nonce               string          `nimona:"nonce:s,omitempty"`
		QueryVector         []uint64        `nimona:"queryVector:au,omitempty"`
		RequireCapabilities []string        `nimona:"requireCapabilities:as,omitempty"`
	}
	LookupResponse struct {
		Metadata      object.Metadata `nimona:"metadata:m,omitempty"`
		Nonce         string          `nimona:"nonce:s,omitempty"`
		QueryVector   []uint64        `nimona:"queryVector:au,omitempty"`
		Announcements []*Announcement `nimona:"announcements:ao,omitempty"`
	}
)

func (e *Announcement) Type() string {
	return "nimona.io/hyperspace.Announcement"
}

func (e Announcement) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/hyperspace.Announcement",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["version"] = object.Int(e.Version)
	r.Data["version"] = object.Int(e.Version)
	// else if $member.IsObject
	if e.ConnectionInfo != nil {
		r.Data["connectionInfo"] = e.ConnectionInfo.ToObject()
	}
	// if $member.IsRepeated
	if len(e.PeerVector) > 0 {
		// else
		// r.Data["peerVector"] = object.ToUintArray(e.PeerVector)
		rv := make(object.UintArray, len(e.PeerVector))
		for i, iv := range e.PeerVector {
			rv[i] = object.Uint(iv)
		}
		r.Data["peerVector"] = rv
	}
	// if $member.IsRepeated
	if len(e.PeerCapabilities) > 0 {
		// else
		// r.Data["peerCapabilities"] = object.ToStringArray(e.PeerCapabilities)
		rv := make(object.StringArray, len(e.PeerCapabilities))
		for i, iv := range e.PeerCapabilities {
			rv[i] = object.String(iv)
		}
		r.Data["peerCapabilities"] = rv
	}
	return r
}

func (e *Announcement) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["version"]; ok {
		if t, ok := v.(object.Int); ok {
			e.Version = int64(t)
		}
	}
	if v, ok := o.Data["connectionInfo"]; ok {
		if t, ok := v.(object.Map); ok {
			es := &peer.ConnectionInfo{}
			eo := object.FromMap(t)
			es.FromObject(eo)
			e.ConnectionInfo = es
		} else if t, ok := v.(*object.Object); ok {
			es := &peer.ConnectionInfo{}
			es.FromObject(t)
			e.ConnectionInfo = es
		}
	}
	if v, ok := o.Data["peerVector"]; ok {
		if t, ok := v.(object.UintArray); ok {
			rv := make([]uint64, len(t))
			for i, iv := range t {
				rv[i] = uint64(iv)
			}
			e.PeerVector = rv
		}
	}
	if v, ok := o.Data["peerCapabilities"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.PeerCapabilities = rv
		}
	}
	return nil
}

func (e *LookupRequest) Type() string {
	return "nimona.io/hyperspace.LookupRequest"
}

func (e LookupRequest) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/hyperspace.LookupRequest",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["nonce"] = object.String(e.Nonce)
	r.Data["nonce"] = object.String(e.Nonce)
	// if $member.IsRepeated
	if len(e.QueryVector) > 0 {
		// else
		// r.Data["queryVector"] = object.ToUintArray(e.QueryVector)
		rv := make(object.UintArray, len(e.QueryVector))
		for i, iv := range e.QueryVector {
			rv[i] = object.Uint(iv)
		}
		r.Data["queryVector"] = rv
	}
	// if $member.IsRepeated
	if len(e.RequireCapabilities) > 0 {
		// else
		// r.Data["requireCapabilities"] = object.ToStringArray(e.RequireCapabilities)
		rv := make(object.StringArray, len(e.RequireCapabilities))
		for i, iv := range e.RequireCapabilities {
			rv[i] = object.String(iv)
		}
		r.Data["requireCapabilities"] = rv
	}
	return r
}

func (e *LookupRequest) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["nonce"]; ok {
		if t, ok := v.(object.String); ok {
			e.Nonce = string(t)
		}
	}
	if v, ok := o.Data["queryVector"]; ok {
		if t, ok := v.(object.UintArray); ok {
			rv := make([]uint64, len(t))
			for i, iv := range t {
				rv[i] = uint64(iv)
			}
			e.QueryVector = rv
		}
	}
	if v, ok := o.Data["requireCapabilities"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]string, len(t))
			for i, iv := range t {
				rv[i] = string(iv)
			}
			e.RequireCapabilities = rv
		}
	}
	return nil
}

func (e *LookupResponse) Type() string {
	return "nimona.io/hyperspace.LookupResponse"
}

func (e LookupResponse) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/hyperspace.LookupResponse",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["nonce"] = object.String(e.Nonce)
	r.Data["nonce"] = object.String(e.Nonce)
	// if $member.IsRepeated
	if len(e.QueryVector) > 0 {
		// else
		// r.Data["queryVector"] = object.ToUintArray(e.QueryVector)
		rv := make(object.UintArray, len(e.QueryVector))
		for i, iv := range e.QueryVector {
			rv[i] = object.Uint(iv)
		}
		r.Data["queryVector"] = rv
	}
	// if $member.IsRepeated
	if len(e.Announcements) > 0 {
		// if $member.IsObject
		rv := make(object.ObjectArray, len(e.Announcements))
		for i, v := range e.Announcements {
			rv[i] = v.ToObject()
		}
		r.Data["announcements"] = rv
	}
	return r
}

func (e *LookupResponse) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["nonce"]; ok {
		if t, ok := v.(object.String); ok {
			e.Nonce = string(t)
		}
	}
	if v, ok := o.Data["queryVector"]; ok {
		if t, ok := v.(object.UintArray); ok {
			rv := make([]uint64, len(t))
			for i, iv := range t {
				rv[i] = uint64(iv)
			}
			e.QueryVector = rv
		}
	}
	if v, ok := o.Data["announcements"]; ok {
		if t, ok := v.(object.MapArray); ok {
			e.Announcements = make([]*Announcement, len(t))
			for i, iv := range t {
				es := &Announcement{}
				eo := object.FromMap(iv)
				es.FromObject(eo)
				e.Announcements[i] = es
			}
		} else if t, ok := v.(object.ObjectArray); ok {
			e.Announcements = make([]*Announcement, len(t))
			for i, iv := range t {
				es := &Announcement{}
				es.FromObject(iv)
				e.Announcements[i] = es
			}
		}
	}
	return nil
}
