// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package object

import (
	crypto "nimona.io/pkg/crypto"
	"nimona.io/pkg/immutable"
)

type (
	Certificate struct {
		Header  Header
		Subject crypto.PublicKey
		Created string
		Expires string
	}
)

func (e Certificate) GetType() string {
	return "nimona.io/object.Certificate"
}

func (e Certificate) GetSchema() *SchemaObject {
	return &SchemaObject{
		Properties: []*SchemaProperty{
			&SchemaProperty{
				Name:       "subject",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "created",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "expires",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e Certificate) ToObject() Object {
	d := map[string]interface{}{}
	if e.Subject != "" {
		d["subject:s"] = e.Subject
	}
	if e.Created != "" {
		d["created:s"] = e.Created
	}
	if e.Expires != "" {
		d["expires:s"] = e.Expires
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:o"] = schema.ToObject().ToMap()
	// }
	o := Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/object.Certificate")
	return o
}

func (e *Certificate) FromObject(o Object) error {
	e.Header = o.Header
	if v := o.Data.Value("subject:s"); v != nil {
		e.Subject = crypto.PublicKey(v.PrimitiveHinted().(string))
	}
	if v := o.Data.Value("created:s"); v != nil {
		e.Created = string(v.PrimitiveHinted().(string))
	}
	if v := o.Data.Value("expires:s"); v != nil {
		e.Expires = string(v.PrimitiveHinted().(string))
	}
	return nil
}
