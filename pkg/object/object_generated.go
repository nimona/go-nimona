// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package object

import (
	json "encoding/json"

	crypto "nimona.io/pkg/crypto"
)

type (
	Header struct {
		Ctx       string             `json:"ctx:s,omitempty"`
		Type      string             `json:"type:s,omitempty"`
		Stream    Hash               `json:"stream:s,omitempty"`
		Parents   []Hash             `json:"parents:as,omitempty"`
		Policy    *Policy            `json:"policy:o,omitempty"`
		Signature *Signature         `json:"signature:o,omitempty"`
		Owners    []crypto.PublicKey `json:"owners:as,omitempty"`
	}
	Policy struct {
		Description string   `json:"description:s,omitempty"`
		Subjects    []string `json:"subjects:as,omitempty"`
		Actions     []string `json:"actions:as,omitempty"`
		Effect      string   `json:"effect:s,omitempty"`
	}
)

func (e Header) GetType() string {
	return "nimona.io/object.Header"
}
func (e Header) GetSchema() *SchemaObject {
	return &SchemaObject{
		Properties: []*SchemaProperty{
			&SchemaProperty{
				Name:       "ctx",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "type",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "stream",
				Type:       "nimona.io/object.Hash",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "parents",
				Type:       "nimona.io/object.Hash",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "policy",
				Type:       "nimona.io/object.Policy",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "signature",
				Type:       "nimona.io/object.Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "owners",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
		},
	}
}

func (e Header) ToObject() Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/object.Header"
	if e.Ctx != "" {
		m["ctx:s"] = e.Ctx
	}
	if e.Type != "" {
		m["type:s"] = e.Type
	}
	if e.Stream != "" {
		m["stream:s"] = e.Stream
	}
	if len(e.Parents) > 0 {
		m["parents:as"] = e.Parents
	}
	if e.Policy != nil {
		m["policy:o"] = e.Policy.ToObject().ToMap()
	}
	if e.Signature != nil {
		m["signature:o"] = e.Signature.ToObject().ToMap()
	}
	if len(e.Owners) > 0 {
		m["owners:as"] = e.Owners
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return Object(m)
}

func (e *Header) FromObject(o Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e Policy) GetType() string {
	return "nimona.io/object.Policy"
}
func (e Policy) GetSchema() *SchemaObject {
	return &SchemaObject{
		Properties: []*SchemaProperty{
			&SchemaProperty{
				Name:       "description",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "subjects",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "actions",
				Type:       "string",
				Hint:       "s",
				IsRepeated: true,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "effect",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e Policy) ToObject() Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/object.Policy"
	if e.Description != "" {
		m["description:s"] = e.Description
	}
	if len(e.Subjects) > 0 {
		m["subjects:as"] = e.Subjects
	}
	if len(e.Actions) > 0 {
		m["actions:as"] = e.Actions
	}
	if e.Effect != "" {
		m["effect:s"] = e.Effect
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return Object(m)
}

func (e *Policy) FromObject(o Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
