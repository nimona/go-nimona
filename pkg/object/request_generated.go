// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package object

import (
	crypto "nimona.io/pkg/crypto"
	"nimona.io/pkg/errors"
)

type (
	Request struct {
		raw        Object
		Stream     Hash
		Parents    []Hash
		Owners     []crypto.PublicKey
		Policy     Policy
		Signatures []Signature
		ObjectHash Hash
	}
	Response struct {
		raw        Object
		Stream     Hash
		Parents    []Hash
		Owners     []crypto.PublicKey
		Policy     Policy
		Signatures []Signature
		ObjectHash *Object
	}
)

func (e Request) GetType() string {
	return "nimona.io/Request"
}

func (e Request) IsStreamRoot() bool {
	return false
}

func (e Request) GetSchema() *SchemaObject {
	return &SchemaObject{
		Properties: []*SchemaProperty{{
			Name:       "objectHash",
			Type:       "nimona.io/Hash",
			Hint:       "s",
			IsRepeated: false,
			IsOptional: false,
		}},
	}
}

func (e Request) ToObject() Object {
	o := Object{}
	o = o.SetType("nimona.io/Request")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.ObjectHash != "" {
		o = o.Set("objectHash:s", e.ObjectHash)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *Request) FromObject(o Object) error {
	data, ok := o.Raw().Value("data:m").(Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("objectHash:s"); v != nil {
		e.ObjectHash = Hash(v.PrimitiveHinted().(string))
	}
	return nil
}

func (e Response) GetType() string {
	return "nimona.io/Response"
}

func (e Response) IsStreamRoot() bool {
	return false
}

func (e Response) GetSchema() *SchemaObject {
	return &SchemaObject{
		Properties: []*SchemaProperty{{
			Name:       "objectHash",
			Type:       "nimona.io/Object",
			Hint:       "m",
			IsRepeated: false,
			IsOptional: false,
		}},
	}
}

func (e Response) ToObject() Object {
	o := Object{}
	o = o.SetType("nimona.io/Response")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.ObjectHash != nil {
		o = o.Set("objectHash:m", e.ObjectHash.ToObject().Raw())
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *Response) FromObject(o Object) error {
	data, ok := o.Raw().Value("data:m").(Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("objectHash:m"); v != nil && v.IsMap() {
		eo := Object(v.(Map))
		e.ObjectHash = &eo
	}
	return nil
}
