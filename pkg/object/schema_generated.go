// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package object

import (
	crypto "nimona.io/pkg/crypto"
	"nimona.io/pkg/errors"
	immutable "nimona.io/pkg/immutable"
)

type (
	SchemaProperty struct {
		raw        Object
		Stream     Hash
		Parents    []Hash
		Owners     []crypto.PublicKey
		Policy     Policy
		Signatures []Signature
		Name       string
		Type       string
		Hint       string
		IsRepeated bool
		IsOptional bool
		Properties []*SchemaProperty
	}
	SchemaObject struct {
		raw        Object
		Stream     Hash
		Parents    []Hash
		Owners     []crypto.PublicKey
		Policy     Policy
		Signatures []Signature
		Properties []*SchemaProperty
	}
)

func (e SchemaProperty) GetType() string {
	return "nimona.io/SchemaProperty"
}

func (e SchemaProperty) ToObject() Object {
	o := Object{}
	o = o.SetType("nimona.io/SchemaProperty")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if e.Name != "" {
		o = o.Set("name:s", e.Name)
	}
	if e.Type != "" {
		o = o.Set("type:s", e.Type)
	}
	if e.Hint != "" {
		o = o.Set("hint:s", e.Hint)
	}
	o = o.Set("isRepeated:b", e.IsRepeated)
	o = o.Set("isOptional:b", e.IsOptional)
	if len(e.Properties) > 0 {
		v := immutable.List{}
		for _, iv := range e.Properties {
			v = v.Append(iv.ToObject().Raw())
		}
		o = o.Set("properties:ao", v)
	}
	return o
}

func (e *SchemaProperty) FromObject(o Object) error {
	data, ok := o.Raw().Value("data:o").(immutable.Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("name:s"); v != nil {
		e.Name = string(v.PrimitiveHinted().(string))
	}
	if v := data.Value("type:s"); v != nil {
		e.Type = string(v.PrimitiveHinted().(string))
	}
	if v := data.Value("hint:s"); v != nil {
		e.Hint = string(v.PrimitiveHinted().(string))
	}
	if v := data.Value("isRepeated:b"); v != nil {
		e.IsRepeated = bool(v.PrimitiveHinted().(bool))
	}
	if v := data.Value("isOptional:b"); v != nil {
		e.IsOptional = bool(v.PrimitiveHinted().(bool))
	}
	if v := data.Value("properties:ao"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]interface{})
		e.Properties = make([]*SchemaProperty, len(m))
		for i, iv := range m {
			es := &SchemaProperty{}
			eo := FromMap(iv.(map[string]interface{}))
			es.FromObject(eo)
			e.Properties[i] = es
		}
	}
	return nil
}

func (e SchemaObject) GetType() string {
	return "nimona.io/SchemaObject"
}

func (e SchemaObject) ToObject() Object {
	o := Object{}
	o = o.SetType("nimona.io/SchemaObject")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if len(e.Properties) > 0 {
		v := immutable.List{}
		for _, iv := range e.Properties {
			v = v.Append(iv.ToObject().Raw())
		}
		o = o.Set("properties:ao", v)
	}
	return o
}

func (e *SchemaObject) FromObject(o Object) error {
	data, ok := o.Raw().Value("data:o").(immutable.Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("properties:ao"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]interface{})
		e.Properties = make([]*SchemaProperty, len(m))
		for i, iv := range m {
			es := &SchemaProperty{}
			eo := FromMap(iv.(map[string]interface{}))
			es.FromObject(eo)
			e.Properties[i] = es
		}
	}
	return nil
}
