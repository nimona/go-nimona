// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package object

import "nimona.io/pkg/immutable"

type (
	SchemaProperty struct {
		Header     Header
		Name       string
		Type       string
		Hint       string
		IsRepeated bool
		IsOptional bool
		Properties []*SchemaProperty
	}
	SchemaObject struct {
		Header     Header
		Properties []*SchemaProperty
	}
)

func (e SchemaProperty) GetType() string {
	return "nimona.io/SchemaProperty"
}

func (e SchemaProperty) ToObject() Object {
	d := map[string]interface{}{}
	if e.Name != "" {
		d["name:s"] = e.Name
	}
	if e.Type != "" {
		d["type:s"] = e.Type
	}
	if e.Hint != "" {
		d["hint:s"] = e.Hint
	}
	d["isRepeated:b"] = e.IsRepeated
	d["isOptional:b"] = e.IsOptional
	if len(e.Properties) > 0 {
		d["properties:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Properties))
			for i, v := range e.Properties {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}
	o := Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/SchemaProperty")
	return o
}

func (e *SchemaProperty) FromObject(o Object) error {
	e.Header = o.Header
	if v := o.Data.Value("name:s"); v != nil {
		e.Name = string(v.PrimitiveHinted().(string))
	}
	if v := o.Data.Value("type:s"); v != nil {
		e.Type = string(v.PrimitiveHinted().(string))
	}
	if v := o.Data.Value("hint:s"); v != nil {
		e.Hint = string(v.PrimitiveHinted().(string))
	}
	if v := o.Data.Value("isRepeated:b"); v != nil {
		e.IsRepeated = bool(v.PrimitiveHinted().(bool))
	}
	if v := o.Data.Value("isOptional:b"); v != nil {
		e.IsOptional = bool(v.PrimitiveHinted().(bool))
	}
	if v := o.Data.Value("properties:ao"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]interface{})
		e.Properties = make([]*SchemaProperty, len(m))
		for i, iv := range m {
			es := &SchemaProperty{}
			eo := FromMap(iv.(map[string]interface{}))
			es.FromObject(eo)
			e.Properties[i] = es
		}
	}
	return nil
}

func (e SchemaObject) GetType() string {
	return "nimona.io/SchemaObject"
}

func (e SchemaObject) ToObject() Object {
	d := map[string]interface{}{}
	if len(e.Properties) > 0 {
		d["properties:ao"] = func() []interface{} {
			a := make([]interface{}, len(e.Properties))
			for i, v := range e.Properties {
				a[i] = v.ToObject().ToMap()
			}
			return a
		}()
	}
	o := Object{
		Header: e.Header,
		Data:   immutable.AnyToValue(":o", d).(immutable.Map),
	}
	o.SetType("nimona.io/SchemaObject")
	return o
}

func (e *SchemaObject) FromObject(o Object) error {
	e.Header = o.Header
	if v := o.Data.Value("properties:ao"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]interface{})
		e.Properties = make([]*SchemaProperty, len(m))
		for i, iv := range m {
			es := &SchemaProperty{}
			eo := FromMap(iv.(map[string]interface{}))
			es.FromObject(eo)
			e.Properties[i] = es
		}
	}
	return nil
}
