// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package aggregate

type (
	// PubSub -
	PubSub interface {
		Publisher
		Subscriber
	}
	// Publisher deals with the publishing part of our PubSub
	Publisher interface {
		Publish(*AggregateObject)
	}
	// Subscriber deals with the subscribing part of our PubSub
	Subscriber interface {
		Subscribe(chan *AggregateObject, ...filter)
		Unsubscribe(chan *AggregateObject)
	}
	filter     func(*AggregateObject) bool
	subscriber struct {
		filters []filter
		out     chan *AggregateObject
	}
	publisher struct {
		outgoing             chan *AggregateObject
		registerSubscriber   chan *subscriber
		unregisterSubscriber chan chan *AggregateObject
		subscriptions        map[*subscriber]bool
	}
)

// NewPubSub constructs and returns a new PubSub
func NewPubSub() PubSub {
	o := &publisher{
		outgoing:             make(chan *AggregateObject, 100),
		registerSubscriber:   make(chan *subscriber, 1),
		unregisterSubscriber: make(chan chan *AggregateObject, 1),
		subscriptions:        map[*subscriber]bool{},
	}

	go o.process()

	return o
}

// Subscribe to published events with optional filters
func (o *publisher) Subscribe(out chan *AggregateObject, filters ...filter) {
	o.registerSubscriber <- &subscriber{
		out:     out,
		filters: filters,
	}
}

// Unsubscribe given a subscribed channel
func (o *publisher) Unsubscribe(out chan *AggregateObject) {
	o.unregisterSubscriber <- out
}

// Publish to all subscribers
func (o *publisher) Publish(v *AggregateObject) {
	o.outgoing <- v
}

func (o *publisher) process() {
	for {
		select {
		case s := <-o.registerSubscriber:
			o.subscriptions[s] = true

		case s := <-o.unregisterSubscriber:
			for k := range o.subscriptions {
				if k.out == s {
					delete(o.subscriptions, k)
				}
			}

		case e := <-o.outgoing:
			for s := range o.subscriptions {
				publish := true
				for _, f := range s.filters {
					if f(e) == false {
						publish = false
						break
					}
				}
				if publish {
					s.out <- e
				}
			}
		}
	}
}
