// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package object

import (
	json "encoding/json"

	crypto "nimona.io/pkg/crypto"
)

type (
	Certificate struct {
		Subject   crypto.PublicKey `json:"subject:s,omitempty"`
		Created   string           `json:"created:s,omitempty"`
		Expires   string           `json:"expires:s,omitempty"`
		Signature *Signature       `json:"_signature:o,omitempty"`
	}
	Signature struct {
		Signer crypto.PublicKey `json:"signer:s,omitempty"`
		Alg    string           `json:"alg:s,omitempty"`
		X      []byte           `json:"x:d,omitempty"`
	}
)

func (e Certificate) GetType() string {
	return "nimona.io/object.Certificate"
}
func (e Certificate) GetSchema() *SchemaObject {
	return &SchemaObject{
		Properties: []*SchemaProperty{
			&SchemaProperty{
				Name:       "subject",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "created",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "expires",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "_signature",
				Type:       "Signature",
				Hint:       "o",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e Certificate) ToObject() Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/object.Certificate"
	if e.Subject != "" {
		m["subject:s"] = e.Subject
	}
	if e.Created != "" {
		m["created:s"] = e.Created
	}
	if e.Expires != "" {
		m["expires:s"] = e.Expires
	}
	if e.Signature != nil {
		m["_signature:o"] = e.Signature.ToObject().ToMap()
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return Object(m)
}

func (e *Certificate) FromObject(o Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e Signature) GetType() string {
	return "nimona.io/object.Signature"
}
func (e Signature) GetSchema() *SchemaObject {
	return &SchemaObject{
		Properties: []*SchemaProperty{
			&SchemaProperty{
				Name:       "signer",
				Type:       "nimona.io/crypto.PublicKey",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "alg",
				Type:       "string",
				Hint:       "s",
				IsRepeated: false,
				IsOptional: false,
			},
			&SchemaProperty{
				Name:       "x",
				Type:       "data",
				Hint:       "d",
				IsRepeated: false,
				IsOptional: false,
			},
		},
	}
}

func (e Signature) ToObject() Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/object.Signature"
	if e.Signer != "" {
		m["signer:s"] = e.Signer
	}
	if e.Alg != "" {
		m["alg:s"] = e.Alg
	}
	if len(e.X) != 0 {
		m["x:d"] = e.X
	}
	if schema := e.GetSchema(); schema != nil {
		m["_schema:o"] = schema.ToObject().ToMap()
	}
	return Object(m)
}

func (e *Signature) FromObject(o Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
