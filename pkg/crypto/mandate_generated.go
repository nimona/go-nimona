// Code generated by nimona.io/tools/objectify. DO NOT EDIT.

// +build !generate

package crypto

import (
	"nimona.io/pkg/object"
)

// ToMap returns a map compatible with f12n
func (s Mandate) ToMap() map[string]interface{} {
	m := map[string]interface{}{
		"@ctx:s":        "/mandate",
		"description:s": s.Description,
		"effect:s":      s.Effect,
	}
	if s.Signer != nil {
		m["@signer:o"] = s.Signer.ToMap()
	}
	if s.Subject != nil {
		m["subject:o"] = s.Subject.ToMap()
	}
	if s.Resources != nil {
		m["resources:a<s>"] = s.Resources
	}
	if s.Actions != nil {
		m["actions:a<s>"] = s.Actions
	}
	if s.Signature != nil {
		m["@signature:o"] = s.Signature.ToMap()
	}
	return m
}

// ToObject returns a f12n object
func (s Mandate) ToObject() *object.Object {
	return object.NewObjectFromMap(s.ToMap())
}

// FromMap populates the struct from a f12n compatible map
func (s *Mandate) FromMap(m map[string]interface{}) error {
	if v, ok := m["@signer:o"].(map[string]interface{}); ok {
		s.Signer = &Key{}
		if err := s.Signer.FromMap(v); err != nil {
			return err
		}
	} else if v, ok := m["@signer:o"].(*Key); ok {
		s.Signer = v
	}
	if v, ok := m["@signer:o"].(*Key); ok {
		s.Signer = v
	}
	if v, ok := m["subject:o"].(map[string]interface{}); ok {
		s.Subject = &Key{}
		if err := s.Subject.FromMap(v); err != nil {
			return err
		}
	} else if v, ok := m["subject:o"].(*Key); ok {
		s.Subject = v
	}
	if v, ok := m["subject:o"].(*Key); ok {
		s.Subject = v
	}
	if v, ok := m["description:s"].(string); ok {
		s.Description = v
	}
	s.Resources = []string{}
	if ss, ok := m["resources:a<s>"].([]interface{}); ok {
		for _, si := range ss {
			if v, ok := si.(string); ok {
				s.Resources = append(s.Resources, v)
			}
		}
	}
	if v, ok := m["resources:a<s>"].([]string); ok {
		s.Resources = v
	}
	s.Actions = []string{}
	if ss, ok := m["actions:a<s>"].([]interface{}); ok {
		for _, si := range ss {
			if v, ok := si.(string); ok {
				s.Actions = append(s.Actions, v)
			}
		}
	}
	if v, ok := m["actions:a<s>"].([]string); ok {
		s.Actions = v
	}
	if v, ok := m["effect:s"].(string); ok {
		s.Effect = v
	}
	if v, ok := m["@signature:o"].(map[string]interface{}); ok {
		s.Signature = &Signature{}
		if err := s.Signature.FromMap(v); err != nil {
			return err
		}
	} else if v, ok := m["@signature:o"].(*Signature); ok {
		s.Signature = v
	}
	if v, ok := m["@signature:o"].(*Signature); ok {
		s.Signature = v
	}
	return nil
}

// FromObject populates the struct from a f12n object
func (s *Mandate) FromObject(o *object.Object) error {
	return s.FromMap(o.ToMap())
}

// GetType returns the object's type
func (s Mandate) GetType() string {
	return "/mandate"
}
