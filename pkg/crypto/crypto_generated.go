// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package crypto

import (
	json "encoding/json"

	object "nimona.io/pkg/object"
)

type (
	Certificate struct {
		Subject   PublicKey  `json:"subject:s,omitempty"`
		Signature *Signature `json:"signature:o,omitempty"`
	}
	Signature struct {
		Signer *Certificate `json:"signer:o,omitempty"`
		Alg    string       `json:"alg:s,omitempty"`
		X      []byte       `json:"x:d,omitempty"`
	}
)

func (e *Certificate) GetType() string {
	return "nimona.io/crypto.Certificate"
}

func (e *Certificate) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/crypto.Certificate"
	m["subject:s"] = e.Subject
	if e.Signature != nil {
		m["signature:o"] = e.Signature.ToObject().ToMap()
	}
	return object.Object(m)
}

func (e *Certificate) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}

func (e *Signature) GetType() string {
	return "nimona.io/crypto.Signature"
}

func (e *Signature) ToObject() object.Object {
	m := map[string]interface{}{}
	m["@type:s"] = "nimona.io/crypto.Signature"
	if e.Signer != nil {
		m["signer:o"] = e.Signer.ToObject().ToMap()
	}
	m["alg:s"] = e.Alg
	m["x:d"] = e.X
	return object.Object(m)
}

func (e *Signature) FromObject(o object.Object) error {
	b, _ := json.Marshal(map[string]interface{}(o))
	return json.Unmarshal(b, e)
}
