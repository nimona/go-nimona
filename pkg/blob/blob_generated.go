// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package blob

import (
	object "nimona.io/pkg/object"
)

type (
	Chunk struct {
		Metadata object.Metadata
		Data     []byte
	}
	Blob struct {
		Metadata object.Metadata
		Chunks   []object.CID
	}
)

func (e *Chunk) Type() string {
	return "nimona.io/Chunk"
}

func (e *Chunk) MarshalMap() (object.Map, error) {
	return e.ToObject().Map(), nil
}

func (e Chunk) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/Chunk",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	r.Data["data"] = object.Data(e.Data)
	return r
}

func (e *Chunk) UnmarshalMap(m object.Map) error {
	return e.FromObject(object.FromMap(m))
}

func (e *Chunk) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["data"]; ok {
		if t, ok := v.(object.Data); ok {
			e.Data = []byte(t)
		}
	}
	return nil
}

func (e *Blob) Type() string {
	return "nimona.io/Blob"
}

func (e *Blob) MarshalMap() (object.Map, error) {
	return e.ToObject().Map(), nil
}

func (e Blob) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/Blob",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	if len(e.Chunks) > 0 {
		rv := make(object.StringArray, len(e.Chunks))
		for i, iv := range e.Chunks {
			rv[i] = object.String(iv)
		}
		r.Data["chunks"] = rv
	}
	return r
}

func (e *Blob) UnmarshalMap(m object.Map) error {
	return e.FromObject(object.FromMap(m))
}

func (e *Blob) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["chunks"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]object.CID, len(t))
			for i, iv := range t {
				rv[i] = object.CID(iv)
			}
			e.Chunks = rv
		}
	}
	return nil
}
