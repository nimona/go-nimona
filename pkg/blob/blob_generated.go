// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package blob

import (
	object "nimona.io/pkg/object"
)

type (
	Chunk struct {
		Metadata object.Metadata `nimona:"metadata:m,omitempty"`
		Data     []byte          `nimona:"data:d,omitempty"`
	}
	Blob struct {
		Metadata object.Metadata `nimona:"metadata:m,omitempty"`
		Chunks   []object.Hash   `nimona:"chunks:as,omitempty"`
	}
)

func (e *Chunk) Type() string {
	return "nimona.io/Chunk"
}

func (e Chunk) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/Chunk",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// else
	// r.Data["data"] = object.Data(e.Data)
	r.Data["data"] = object.Data(e.Data)
	return r
}

func (e *Chunk) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["data"]; ok {
		if t, ok := v.(object.Data); ok {
			e.Data = []byte(t)
		}
	}
	return nil
}

func (e *Blob) Type() string {
	return "nimona.io/Blob"
}

func (e Blob) ToObject() *object.Object {
	r := &object.Object{
		Type:     "nimona.io/Blob",
		Metadata: e.Metadata,
		Data:     object.Map{},
	}
	// if $member.IsRepeated
	if len(e.Chunks) > 0 {
		// else
		// r.Data["chunks"] = object.ToStringArray(e.Chunks)
		rv := make(object.StringArray, len(e.Chunks))
		for i, iv := range e.Chunks {
			rv[i] = object.String(iv)
		}
		r.Data["chunks"] = rv
	}
	return r
}

func (e *Blob) FromObject(o *object.Object) error {
	e.Metadata = o.Metadata
	if v, ok := o.Data["chunks"]; ok {
		if t, ok := v.(object.StringArray); ok {
			rv := make([]object.Hash, len(t))
			for i, iv := range t {
				rv[i] = object.Hash(iv)
			}
			e.Chunks = rv
		}
	}
	return nil
}
