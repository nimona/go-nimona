// Code generated by nimona.io/tools/codegen. DO NOT EDIT.

package blob

import (
	"errors"

	crypto "nimona.io/pkg/crypto"
	object "nimona.io/pkg/object"
)

type (
	Chunk struct {
		raw        object.Object
		Stream     object.Hash
		Parents    []object.Hash
		Owners     []crypto.PublicKey
		Policy     object.Policy
		Signatures []object.Signature
		Data       []byte
	}
	Blob struct {
		raw        object.Object
		Stream     object.Hash
		Parents    []object.Hash
		Owners     []crypto.PublicKey
		Policy     object.Policy
		Signatures []object.Signature
		Chunks     []*Chunk
	}
)

func (e Chunk) GetType() string {
	return "nimona.io/Chunk"
}

func (e Chunk) IsStreamRoot() bool {
	return false
}

func (e Chunk) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "data",
			Type:       "data",
			Hint:       "d",
			IsRepeated: false,
			IsOptional: false,
		}},
	}
}

func (e Chunk) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("nimona.io/Chunk")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if len(e.Data) != 0 {
		o = o.Set("data:d", e.Data)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *Chunk) FromObject(o object.Object) error {
	data, ok := o.Raw().Value("data:m").(object.Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("data:d"); v != nil {
		e.Data = []byte(v.PrimitiveHinted().([]byte))
	}
	return nil
}

func (e Blob) GetType() string {
	return "nimona.io/Blob"
}

func (e Blob) IsStreamRoot() bool {
	return false
}

func (e Blob) GetSchema() *object.SchemaObject {
	return &object.SchemaObject{
		Properties: []*object.SchemaProperty{{
			Name:       "chunks",
			Type:       "Chunk",
			Hint:       "m",
			IsRepeated: true,
			IsOptional: false,
		}},
	}
}

func (e Blob) ToObject() object.Object {
	o := object.Object{}
	o = o.SetType("nimona.io/Blob")
	if len(e.Stream) > 0 {
		o = o.SetStream(e.Stream)
	}
	if len(e.Parents) > 0 {
		o = o.SetParents(e.Parents)
	}
	if len(e.Owners) > 0 {
		o = o.SetOwners(e.Owners)
	}
	o = o.AddSignature(e.Signatures...)
	o = o.SetPolicy(e.Policy)
	if len(e.Chunks) > 0 {
		v := object.List{}
		for _, iv := range e.Chunks {
			v = v.Append(iv.ToObject().Raw())
		}
		o = o.Set("chunks:am", v)
	}
	// if schema := e.GetSchema(); schema != nil {
	// 	m["_schema:m"] = schema.ToObject().ToMap()
	// }
	return o
}

func (e *Blob) FromObject(o object.Object) error {
	data, ok := o.Raw().Value("data:m").(object.Map)
	if !ok {
		return errors.New("missing data")
	}
	e.raw = object.Object{}
	e.raw = e.raw.SetType(o.GetType())
	e.Stream = o.GetStream()
	e.Parents = o.GetParents()
	e.Owners = o.GetOwners()
	e.Signatures = o.GetSignatures()
	e.Policy = o.GetPolicy()
	if v := data.Value("chunks:am"); v != nil && v.IsList() {
		m := v.PrimitiveHinted().([]interface{})
		e.Chunks = make([]*Chunk, len(m))
		for i, iv := range m {
			es := &Chunk{}
			eo := object.FromMap(iv.(map[string]interface{}))
			es.FromObject(eo)
			e.Chunks[i] = es
		}
	}
	return nil
}
