// Code generated by MockGen. DO NOT EDIT.
// Source: mesh.go

// Package meshmock is a generated GoMock package.
package meshmock

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	net "nimona.io/internal/net"
	context "nimona.io/pkg/context"
	crypto "nimona.io/pkg/crypto"
	mesh "nimona.io/pkg/mesh"
	object "nimona.io/pkg/object"
	peer "nimona.io/pkg/peer"
)

// MockResolver is a mock of Resolver interface.
type MockResolver struct {
	ctrl     *gomock.Controller
	recorder *MockResolverMockRecorder
}

// MockResolverMockRecorder is the mock recorder for MockResolver.
type MockResolverMockRecorder struct {
	mock *MockResolver
}

// NewMockResolver creates a new mock instance.
func NewMockResolver(ctrl *gomock.Controller) *MockResolver {
	mock := &MockResolver{ctrl: ctrl}
	mock.recorder = &MockResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResolver) EXPECT() *MockResolverMockRecorder {
	return m.recorder
}

// LookupPeer mocks base method.
func (m *MockResolver) LookupPeer(ctx context.Context, publicKey crypto.PublicKey) (*peer.ConnectionInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LookupPeer", ctx, publicKey)
	ret0, _ := ret[0].(*peer.ConnectionInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LookupPeer indicates an expected call of LookupPeer.
func (mr *MockResolverMockRecorder) LookupPeer(ctx, publicKey interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookupPeer", reflect.TypeOf((*MockResolver)(nil).LookupPeer), ctx, publicKey)
}

// MockMesh is a mock of Mesh interface.
type MockMesh struct {
	ctrl     *gomock.Controller
	recorder *MockMeshMockRecorder
}

// MockMeshMockRecorder is the mock recorder for MockMesh.
type MockMeshMockRecorder struct {
	mock *MockMesh
}

// NewMockMesh creates a new mock instance.
func NewMockMesh(ctrl *gomock.Controller) *MockMesh {
	mock := &MockMesh{ctrl: ctrl}
	mock.recorder = &MockMeshMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMesh) EXPECT() *MockMeshMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockMesh) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockMeshMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockMesh)(nil).Close))
}

// GetAddresses mocks base method.
func (m *MockMesh) GetAddresses() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAddresses")
	ret0, _ := ret[0].([]string)
	return ret0
}

// GetAddresses indicates an expected call of GetAddresses.
func (mr *MockMeshMockRecorder) GetAddresses() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddresses", reflect.TypeOf((*MockMesh)(nil).GetAddresses))
}

// GetConnectionInfo mocks base method.
func (m *MockMesh) GetConnectionInfo() *peer.ConnectionInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetConnectionInfo")
	ret0, _ := ret[0].(*peer.ConnectionInfo)
	return ret0
}

// GetConnectionInfo indicates an expected call of GetConnectionInfo.
func (mr *MockMeshMockRecorder) GetConnectionInfo() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConnectionInfo", reflect.TypeOf((*MockMesh)(nil).GetConnectionInfo))
}

// GetPeerKey mocks base method.
func (m *MockMesh) GetPeerKey() crypto.PrivateKey {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPeerKey")
	ret0, _ := ret[0].(crypto.PrivateKey)
	return ret0
}

// GetPeerKey indicates an expected call of GetPeerKey.
func (mr *MockMeshMockRecorder) GetPeerKey() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPeerKey", reflect.TypeOf((*MockMesh)(nil).GetPeerKey))
}

// GetRelays mocks base method.
func (m *MockMesh) GetRelays() []*peer.ConnectionInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRelays")
	ret0, _ := ret[0].([]*peer.ConnectionInfo)
	return ret0
}

// GetRelays indicates an expected call of GetRelays.
func (mr *MockMeshMockRecorder) GetRelays() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRelays", reflect.TypeOf((*MockMesh)(nil).GetRelays))
}

// Listen mocks base method.
func (m *MockMesh) Listen(ctx context.Context, bindAddress string, options ...mesh.ListenOption) (net.Listener, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, bindAddress}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Listen", varargs...)
	ret0, _ := ret[0].(net.Listener)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Listen indicates an expected call of Listen.
func (mr *MockMeshMockRecorder) Listen(ctx, bindAddress interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, bindAddress}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Listen", reflect.TypeOf((*MockMesh)(nil).Listen), varargs...)
}

// RegisterAddresses mocks base method.
func (m *MockMesh) RegisterAddresses(arg0 ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RegisterAddresses", varargs...)
}

// RegisterAddresses indicates an expected call of RegisterAddresses.
func (mr *MockMeshMockRecorder) RegisterAddresses(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterAddresses", reflect.TypeOf((*MockMesh)(nil).RegisterAddresses), arg0...)
}

// RegisterRelays mocks base method.
func (m *MockMesh) RegisterRelays(arg0 ...*peer.ConnectionInfo) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RegisterRelays", varargs...)
}

// RegisterRelays indicates an expected call of RegisterRelays.
func (mr *MockMeshMockRecorder) RegisterRelays(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterRelays", reflect.TypeOf((*MockMesh)(nil).RegisterRelays), arg0...)
}

// RegisterResolver mocks base method.
func (m *MockMesh) RegisterResolver(resolver mesh.Resolver) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterResolver", resolver)
}

// RegisterResolver indicates an expected call of RegisterResolver.
func (mr *MockMeshMockRecorder) RegisterResolver(resolver interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterResolver", reflect.TypeOf((*MockMesh)(nil).RegisterResolver), resolver)
}

// Send mocks base method.
func (m *MockMesh) Send(ctx context.Context, object *object.Object, publicKey crypto.PublicKey, sendOptions ...mesh.SendOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, object, publicKey}
	for _, a := range sendOptions {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Send", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Send indicates an expected call of Send.
func (mr *MockMeshMockRecorder) Send(ctx, object, publicKey interface{}, sendOptions ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, object, publicKey}, sendOptions...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockMesh)(nil).Send), varargs...)
}

// Subscribe mocks base method.
func (m *MockMesh) Subscribe(filters ...mesh.EnvelopeFilter) mesh.EnvelopeSubscription {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range filters {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(mesh.EnvelopeSubscription)
	return ret0
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockMeshMockRecorder) Subscribe(filters ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockMesh)(nil).Subscribe), filters...)
}

// SubscribeOnce mocks base method.
func (m *MockMesh) SubscribeOnce(ctx context.Context, filters ...mesh.EnvelopeFilter) (*mesh.Envelope, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range filters {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeOnce", varargs...)
	ret0, _ := ret[0].(*mesh.Envelope)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeOnce indicates an expected call of SubscribeOnce.
func (mr *MockMeshMockRecorder) SubscribeOnce(ctx interface{}, filters ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, filters...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeOnce", reflect.TypeOf((*MockMesh)(nil).SubscribeOnce), varargs...)
}
