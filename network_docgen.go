// Code generated by nimona.io. DO NOT EDIT.

package nimona

import (
	"github.com/vikyd/zero"
)

var _ = zero.IsZeroVal

func (t *NetworkAlias) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/network/alias"
	}

	// # t.Hostname
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["hostname"] = t.Hostname
	}

	return m
}

func (t *NetworkAlias) FromDocumentMap(m DocumentMap) {
	*t = NetworkAlias{}

	// # t.Hostname
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		if v, ok := m["hostname"].(string); ok {
			t.Hostname = v
		}
	}

}
func (t *NetworkIdentity) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/network/identity"
	}

	// # t.NetworkAlias
	//
	// Type: nimona.NetworkAlias, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.NetworkAlias) {
			m["networkAlias"] = t.NetworkAlias.DocumentMap()
		}
	}

	// # t.NetworkInfoRootID
	//
	// Type: nimona.DocumentID, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.NetworkInfoRootID) {
			m["networkInfoRootID"] = t.NetworkInfoRootID.DocumentMap()
		}
	}

	return m
}

func (t *NetworkIdentity) FromDocumentMap(m DocumentMap) {
	*t = NetworkIdentity{}

	// # t.NetworkAlias
	//
	// Type: nimona.NetworkAlias, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["networkAlias"].(DocumentMap); ok {
			e := NetworkAlias{}
			e.FromDocumentMap(v)
			t.NetworkAlias = e
		}
	}

	// # t.NetworkInfoRootID
	//
	// Type: nimona.DocumentID, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["networkInfoRootID"].(DocumentMap); ok {
			e := DocumentID{}
			e.FromDocumentMap(v)
			t.NetworkInfoRootID = e
		}
	}

}
func (t *NetworkInfo) DocumentMap() DocumentMap {
	m := DocumentMap{}

	// # t.$type
	//
	// Type: string, Kind: string
	// IsSlice: false, IsStruct: false, IsPointer: false
	{
		m["$type"] = "core/network/info"
	}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if !zero.IsZeroVal(t.Metadata) {
			m["$metadata"] = t.Metadata.DocumentMap()
		}
	}

	// # t.NetworkAlias
	//
	// Type: nimona.NetworkAlias, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		m["networkAlias"] = t.NetworkAlias.DocumentMap()
	}

	// # t.PeerAddresses
	//
	// Type: []nimona.PeerAddr, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.PeerAddr, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []any{}
		for _, v := range t.PeerAddresses {
			if !zero.IsZeroVal(t.PeerAddresses) {
				sm = append(sm, v.DocumentMap())
			}
		}
		m["peerAddresses"] = sm
	}

	return m
}

func (t *NetworkInfo) FromDocumentMap(m DocumentMap) {
	*t = NetworkInfo{}

	// # t.Metadata
	//
	// Type: nimona.Metadata, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["$metadata"].(DocumentMap); ok {
			e := Metadata{}
			e.FromDocumentMap(v)
			t.Metadata = e
		}
	}

	// # t.NetworkAlias
	//
	// Type: nimona.NetworkAlias, Kind: struct
	// IsSlice: false, IsStruct: true, IsPointer: false
	{
		if v, ok := m["networkAlias"].(DocumentMap); ok {
			e := NetworkAlias{}
			e.FromDocumentMap(v)
			t.NetworkAlias = e
		}
	}

	// # t.PeerAddresses
	//
	// Type: []nimona.PeerAddr, Kind: slice
	// IsSlice: true, IsStruct: false, IsPointer: false
	//
	// ElemType: nimona.PeerAddr, ElemKind: struct
	// IsElemSlice: false, IsElemStruct: true, IsElemPointer: false
	{
		sm := []PeerAddr{}
		if vs, ok := m["peerAddresses"].([]any); ok {
			for _, vi := range vs {
				v, ok := vi.(DocumentMap)
				if ok {
					e := PeerAddr{}
					e.FromDocumentMap(v)
					sm = append(sm, e)
				}
			}
		}
		if len(sm) > 0 {
			t.PeerAddresses = sm
		}
	}

}
